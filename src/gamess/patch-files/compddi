#!/bin/csh -f
#
#  15 Feb 11 - script to compile the Distributed Data Interface (DDI)
#
#     This produces a library 'libddi.a' which GAMESS links against,
#     and perhaps, a process kickoff program called 'ddikick.x' and
#     perhaps a test program 'ddi_test.x'.
#
if (-e install.info) then
   source install.info
else if (-e ../install.info) then
   source ../install.info
else
   echo "Please run 'config' first, to set up GAMESS compiling information"
   exit 4
endif
#
#  the configuration file read just above provides the next two variables,
#  and several other GMS_XXX values that will be used further down.
#
set TARGET=$GMS_TARGET
chdir $GMS_PATH/ddi
#
#  The following "numbers" make choices based primarily on 'config' values,
#  such as the machine target, and communication layer.
#  A human might want to review some of these selections, particularly #2,
#  but if you don't understand something, leave it alone.
#
#  1. Choose DDI communication layer, the only legal values are
#              sockets,mixed,mpi,shmem,lapi,armci
#     Please note that the correct choice is very often "sockets"!
#
#     Use 'sockets' if a TCP/IP stack is available.
#                   Choosing 'sockets' will produce a process kickoff
#                   program 'ddikick.x', as well as the DDI library.
#                   Every Unix has TCP/IP for its Ethernet, and "sockets"
#                   is an highly rational choice for Ethernet clusters.
#     Use 'mixed' or 'mpi' for MPI-based high performance networks.
#           'mixed' uses almost entirely MPI-1 calls, but uses a few
#                   TCP/IP sockets to avoid some of MPI's polling, often
#                   resulting in better wall clock times than 100% MPI.
#             'mpi' runs use 100% MPI-1 calls, but this often bogs down
#                   in polling, and can be much slower than 'mixed'.
#                         Read about MPI in ~/gamess/ddi/readme.ddi
#                         before choosing either 'mixed' or 'mpi'.
#     Use    'lapi' only on the IBM SP platform.
#     Use   'armci' for the IBM Blue Gene/L platform.
#     Use     'mpi' for the IBM Blue Gene/P platform.
#     Use     'mpi' for the Cray XT series.
#     Use     'mpi' for the SGI Altix or ICE, with its 'mpt' MPI library.
#     Use   'shmem' for the Cray X1 or X2 vector systems.
#     Use   'shmem' for the SGI Origin.
#
#     Clusters should use TCP/IP sockets on networks up to and including GE,
#     but probably should use 'mpi' on networks like Infiniband.
#
#  As of Feb. 2011, 'config' usually sets GMS_DDI_COMM to 'sockets'.
#       However, target 'linux64' may set GMS_DDI_COMM to 'mpi',
#  along with collecting information about which flavor of mpi,
#  where the MPI library is located, and so forth.  
#  Thus IB clusters, presuming they do not select openMPI, should work.
#                                
set COMM = $GMS_DDI_COMM
#
#     high end machines are just hardwired as follows.  Don't change them.
#
if ($TARGET != ibm-bg) set GMS_BG_MODEL=" "
if ($TARGET != ibm-bg) set GMS_ARMCI_PATH=" "
#
if  ($TARGET == cray-xt)                         set COMM=mpi
if (($TARGET == ibm-bg) && ($GMS_BG_MODEL == L)) set COMM=armci
if (($TARGET == ibm-bg) && ($GMS_BG_MODEL == P)) set COMM=mpi
if  ($TARGET == ibm64-sp)                        set COMM=lapi
if  ($TARGET == cray-x1)                         set COMM=shmem
if  ($TARGET == sgi64)                           set COMM=shmem

#  2. DDI node sizes
#     a. Maximum number of processors (cores) in your SMP enclosures
#     b. Maximum number of nodes (number of physical SMP enclosures)
#     It is OK if these values are larger than your system,
#     but a serious error if they are smaller!
#
set MAXCPUS  = 32
set MAXNODES = 256
#
if ($TARGET == cray-xt) then
   set MAXCPUS=12
   set MAXNODES=1024 # bump one or both of these to match your XT
endif

if ($TARGET == ibm-bg) then
   if ($GMS_BG_MODEL == L) then
      set MAXCPUS=2
      set MAXNODES=1024 # bump to match your BG/L
   endif
   if ($GMS_BG_MODEL == P) then
      set MAXCPUS=4
      set MAXNODES=4096 # bump to match your BG/P
   endif
endif

#  3. Use System V-style shared-memory
#        Please see the file readme.ddi for checking and changing
#        System V shared memory/IPC limits for your particular OS.
#        Turn System V memory off if:
#        1) if you are unable to adjust system limits to higher values,
#           which requires cooperation from the 'root' account.
#        2) on some systems with micro-kernels, SysV may be taboo.
#        3) if SysV is just missing, e.g. in Cygwin under Windows.
#
set SYSV = true
if ($TARGET == ibm-bg)   set SYSV=false
if ($COMM == armci)      set SYSV=false
if ($TARGET == win32)    set SYSV=false
if ($TARGET == win64)    set SYSV=false

#  5.    If you are unable to compile the new DDI source code, in case
#        your operating system is very old (e.g. > 10 years) you might
#        choose to compile the original version of DDI by picking 'old'.
#        The execution script 'rungms' will need to use the old syntax
#        for ddikick.x, see 'readme.ddi' and inside that script.
#
set DDI_SOURCE=new

#  6. If using MPI, select the path to the include file mpi.h
#     This part is for Linux clusters, where there are many different
#     MPI libraries, and they may be installed almost anywhere.
#
#     For example, Intel MPI version 3.2 installed at the default
#     place would want to define something like
#        set MPI_INCLUDE_PATH = '/opt/intel/impi/3.2/include64'
#     Other scripting changes related to compiling and linking for
#     an MPI library are the "fge hack" in 'comp', and setting up
#     the message libraries in 'lked'.
#     Execution of GAMESS over MPI is left up to the user's ability
#     to modify 'rungms', based on the information about each MPI
#     contained in 'readme.ddi'!
#
set MPI_INCLUDE_PATH = ''
#
#           big iron knows where its MPI is going to be found
#           initialize this variable so we can take default setups below.
if ($TARGET == ibm-bg)  set GMS_MPI_LIB=IBM-BlueGene-MPI
if ($TARGET == cray-xt) set GMS_MPI_LIB=Cray-XT-MPI
#
#   This is the end of the user selectable "numbered" options!
#
#
# ------------------------------------------------------------------------- #
# Troubleshooting -- If you should run into any errors while compiling,
# check the following lists of common failures.
#
# 1) socklen_t is not defined.  Uncomment the following line.
#    set SOCKLEN_T = "-Dsocklen_t=int"
#
# 2) turn on debugging output.  set DEBUG_LEVEL to the level of debugging.
#    0 ==> Debugging (e.g. arg checking) compiled in, but no extra output.
#          Note that 0 selects more debugging than the normal compilation.
#    1 ==> Minimum debugging output.
#    5 ==> Standard debugging output.
#   10 ==> Significantly more output.
#   15 ==> Even more ... probably best to avoid this one.
#    One can also call DDI_DEBUG(level) to set the desired level
#    around a troublesome piece of code.
#    Uncomment the following line to enable more argument checking:
#
#    set DEBUG_LEVEL=0
#
# 3) If you want debugging output from only a particular CPU.
#    set DEBUG_CPU=RANK
#    set DEBUG_CPU=0
#
# 4) To make all point to point send/recv messages fully synchronous,
#    add the flag "-DSOC_SYNC" somewhere below, if TCP/IP, of course.
#
# ------------------------------------------------------------------------- #

# ------------------------------------------------------------------------- #
# Here is an index of the options that can be defined to the C compiler
#
# -DDDI_SOC  -- use sockets; requires ddikick if mpi is not used.
# -DDDI_MPI  -- use MPI; must be kicked off with MPI kickoff;
#               assumes 1:1 mapping of compute processes and data servers
# -DDDI_LAPI -- use LAPI for distributed data operations; kickoff using
#               the poe command; NO data servers
# -DUSE_SYSV -- make use of System V shared-memory
#
# -DMACHINE              -- defines the target architecture
# -D_32_BIT              -- specifies a 32-bit machine (64-bit default)
# -DINT_SIZE=(int,long)  -- defines the size of a FORTRAN integer
# -D_UNDERSCORES=(0,1,2) -- number of underscores on a FORTRAN object
# -DF77_UPPERCASE        -- use UPPERCASE names for FORTRAN objects
#
# ------------------------------------------------------------------------- #


echo "       Building the Distributed Data Interface library"
echo "           started at `date`"
echo " "
if ($DDI_SOURCE == new) then
   echo "Compiling for machine type $TARGET,"
   echo "using communication model $COMM,"
   echo "System V shared memory option set $SYSV,"
   echo "with maxima of $MAXCPUS processors/node and $MAXNODES nodes."
else
   echo "Note, using DDI version 1 source code, for machine $TARGET."
endif
echo " "
echo "This compilation should produce the DDI library libddi.a"
#
if ($COMM == sockets) \
echo "This compilation should also produce the kick-off program ddikick.x"
#
echo " "
#
if (($GMS_DDI_COMM == mpi) || ($GMS_DDI_COMM == mixed)) then
   switch ($GMS_MPI_LIB)
     case impi:
        set MPI_INCLUDE_PATH = "$GMS_MPI_PATH/include64"
        breaksw
     case mpich2:
     case mvapich2:
     case myrinet:
     case openmpi:
     case mpt:
        set MPI_INCLUDE_PATH = "$GMS_MPI_PATH/include"
        breaksw
#            MicroSoft MPI uses a compiler flag, set below, not a pathname
     case msmpi:
        if($GMS_FORTRAN == pgf77) set MPI_INCLUDE_PATH = " "
        goto skip_mpi_setup
        breaksw
#            big machines will find their mpi.f, don't check it.
     case IBM-BlueGene-MPI:
     case Cray-XT-MPI:
        goto skip_mpi_setup
        breaksw
     default:
        echo "unknown MPI software requested"
        exit 4
        breaksw
   endsw
#         Double check that a valid path to MPI was provided.
#         Checking omitted in comp/lked as probably compddi will be run 1st.
   if (-e $MPI_INCLUDE_PATH/mpi.h) then
      echo "The MPI-1 software library to be used is $GMS_MPI_LIB,"
      echo "with the include file 'mpi.h' at $MPI_INCLUDE_PATH"
   else
      echo "Something is wrong with your MPI definitions in 'config',"
      echo "since there is no such file $MPI_INCLUDE_PATH/mpi.h"
      exit 4
   endif
endif
#
skip_mpi_setup:

echo " "

# ------------- set options forced by the choices made above ------------- #

# --------------------- #
# Communication Options #
# --------------------- #
  if($COMM == sockets) then
     set DDI_COMM = '-DDDI_SOC'
  endif

  if($COMM == mixed) then
     set DDI_COMM = '-DDDI_MPI -DDDI_SOC'
  endif

  if($COMM == mpi) then
     set DDI_COMM = '-DDDI_MPI'
  endif

  if($COMM == lapi) then
     set DDI_COMM = '-DDDI_MPI -DDDI_LAPI'
  endif

  if($COMM == shmem) then
     set DDI_COMM = ' '
  endif

  if($COMM == armci) then
     set DDI_COMM = "-DDDI_MPI -DDDI_ARMCI"
     set DDI_COMM = "$DDI_COMM -DDDI_ARMCI_IMPLICIT_NBPUT"
     set DDI_COMM = "$DDI_COMM -DDDI_ARMCI_IMPLICIT_NBGET"
     set DDI_COMM = "$DDI_COMM -DDDI_ARMCI_IMPLICIT_NBACC"
     set DDI_COMM = "$DDI_COMM -DDDI_ARMCI_IMPLICIT_WAIT"
  endif

#        remember, the L is using ARMCI, with all the flags just above
  if ($TARGET == ibm-bg) then
     if ($GMS_BG_MODEL == L) set DDI_COMM = "-DDDI_BGL $DDI_COMM"
     if ($GMS_BG_MODEL == P) set DDI_COMM = "-DDDI_BGP $DDI_COMM"
  endif


# ---------------------- #
# System V Shared-Memory #
# ---------------------- #
  if($SYSV == true) set DDI_COMM = "$DDI_COMM -DUSE_SYSV"


# --------------------- #
# Troubleshooting Flags #
# --------------------- #
  set DDI_OPTS = "$DDI_COMM"
  set DDI_OPTS = "$DDI_OPTS -DMAX_SMP_PROCS=$MAXCPUS -DMAX_NODES=$MAXNODES"

# 1) socklen_t
  if($?SOCKLEN_T == 0) set SOCKLEN_T = " "
  set DDI_OPTS = "$DDI_OPTS $SOCKLEN_T"

# 2) debugging options
  if($?DEBUG_LEVEL == 0) then
     set DEBUG_LEVEL = ""
  else
     set DEBUG_LEVEL = "-DDDI_DEBUG=$DEBUG_LEVEL"
  endif
  set DDI_OPTS = "$DDI_OPTS $DEBUG_LEVEL"

# 3) debugging a particular cpu
  if($?DEBUG_CPU == 0) then
     set DEBUG_CPU = ""
  else
     set DEBUG_CPU = "-DDDI_DEBUG_CPU=$DEBUG_CPU"
  endif
  set DDI_OPTS = "$DDI_OPTS $DEBUG_CPU"


# ------------- start of machine specific option selection -------------- #

  unset CFLAGS

# ------------ #
# Compaq Tru64 #
# ------------ #
#    Notes:
#    AXP systems may be labeled Digital, Compaq, or HP depending on age.
#    Similarly the O/S has various names, including OSF/1, Digital Unix.
#    This target is used for all such systems, and works for Linux too.
#
#    Old C compilers ("cc -V | more -5") such as 5.6 require that you 
#    add -Dsocklen_t=int to CFLAGS below, while newer versions such
#    as 5.9, 6.1, ... have the new data type socklen_t present.
#
  if($TARGET == axp64) then

     set UNAME = `uname`
                         set CC = 'cc'
     if($UNAME == Linux) set CC = 'ccc'
                         set NumUS=1
     if($UNAME == Linux) set NumUS=2
 
     set CFLAGS = "-DCOMPAQ -O4 -ansi_alias -std -I./"
     set CLIBS  = "-lpthread"
     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=$NumUS"
     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'f77'
     if($UNAME == Linux) set FORTRAN = 'fort'
     set FORT_FLAGS = '-i8 -v '
     set FORT_LIBS  = ''

  endif


# ------- #
# Cray X1 #
# ------- #
#     this machine based on an antiquated SHMEM interface,
#     creating serious doubt that this is a working machine.
  if($TARGET == cray-x1) then
     set RANLIB_FLAGS = ' '
     echo "Compiling: ddit3e.o for use on the Cray X1"
     set echo
     #---ftn -O2 -Ossp,aggress -xomp -dp -sdefault64 -c -V shmem/ddit3e.f
     ../comp ddit3e
     unset echo

     if(-e ddit3e.o) then
        ar cr libddi.a ddit3e.o
        rm -f ddit3e.o
        echo "Finished compiling: ddit3e.o"
        goto finishOK
     else
        echo "Error compiling: ddit3e.o"
        exit 4
     endif

     set FORTRAN    = 'ftn'
     set FORT_FLAGS = '-O2 -V -xomp -dp -sdefault64 -Ossp'
     set FORT_LIBS  = ''
  endif


# ------- #
# Cray XT #
# ------- #
if ($TARGET == cray-xt) then
   echo "---------------"
   echo "Loaded modules:"
   echo "---------------"
   module list

#         two choices not included in the configuration step
#         These must match 'comp' and 'lked', and loaded software modules.
#         valid choices: gnu (Ran's choice), pathscale, intel, cray, pgi
   set GMS_XT_COMP = 'pgi'
#            valid choices: i7, barcelona, shanghai, or blank
   set GMS_XT_ARCH = ' '

   set CC='cc'
   set CFLAGS='-DLINUX64 -DCRAY_MPI -DUSE_MPI_BARRIER -I./'

   switch ($GMS_XT_COMP)
      case pgi:
         set CFLAGS="$CFLAGS -O3 -mcmodel=medium -fastsse -Mfpmisalign"
         breaksw
      case pathscale:
         set CFLAGS="$CFLAGS -O3 -m64 -fstrict-aliasing"
         breaksw
      case gnu:
         set CFLAGS="$CFLAGS -O3 -m64 -fstrict-aliasing"
         breaksw
      case intel:
      case cray:
      default:
         set CFLAGS="$CFLAGS -O3"
         breaksw
   endsw

   switch ($GMS_XT_ARCH)
      case barcelona:
         set CFLAGS = "$CFLAGS -tp barcelona-64 -Mfpmisalign"
         breaksw
      case shanghai:
         set CFLAGS = "$CFLAGS -tp shanghai-64 -Mfpmisalign"
         breaksw
      case i7:
         set CFLAGS = "$CFLAGS -tp x64"
         breaksw
      default:
         breaksw
   endsw

   set AR_FLAGS     = 'cr'
   set RANLIB_FLAGS = ' '
   set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=1"
endif

# ------------------- #
# Fujitsu Prime Power #
# ------------------- #
  if($TARGET == fuji-pp32) then
     set CC = 'fcc'
     set CFLAGS='-DSUN32 -O -I./'
     set CLIBS='-lpthread -lsocket -lnsl'
     set F77_OPTS='-DINT_SIZE=int -D_UNDERSCORES=1'
     set AR_FLAGS     = '-cr'
     set RANLIB_FLAGS = '-c'

     set FORTRAN    = 'f90'
     set FORT_FLAGS = '-KV8PLUS -fs'
     set FORT_LIBS  = '-SSL2'
  endif

  if($TARGET == fuji-pp64) then
     set CC = 'fcc'
     set CFLAGS='-KV9 -DSUN64 -O -I./'
     set CLIBS='-KV9 -lsocket -lnsl -lpthread'
     set F77_OPTS='-DINT_SIZE=long -D_UNDERSCORES=1'
     set AR_FLAGS     = '-cr'
     set RANLIB_FLAGS = '-c'

     set FORTRAN    = 'f90'
     set FORT_FLAGS = '-KV9 -fs -CcdII8'
     set FORT_LIBS  = '-SSL2'
  endif


# ----- #
# HP-UX #
# ----- #
  if($TARGET == hpux32) then
     set CC       = 'cc'
     set CFLAGS   = '-DHPUX32 +O3 +DD32 -D_32_BIT +O3 -I./'
     set CLIBS    = '-lpthread'

     set F77_OPTS = '-DINT_SIZE=int -D_UNDERSCORES=0'

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = '-c'

     set FORTRAN    = 'f90'
     set FORT_FLAGS = '+O2 +Ofastaccess +noppu'
     set FORT_LIBS  = '-ldld +U77'
  endif

#    see the note in readme.ddi if you have trouble compiling with
#    the socklen_t redefinition (this may occur on PA-RISC systems).
  if($TARGET == hpux64) then
     set CC     = 'cc'
     set CFLAGS = '-DHPUX64 +O3 +DD64 -D_REENTRANT -Dsocklen_t=int -I./'
     set CLIBS  = '-lpthread'

     set F77_OPTS = '-DINT_SIZE=long -D_UNDERSCORES=0'

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'f90'
     set FORT_FLAGS = '+DD64 +O2 +i8 +noppu'
     set FORT_LIBS  = '-ldld +U77'
  endif


# ---------- #
# IBM 32-bit #
# ---------- #
  if($TARGET == ibm32) then
     set CC = 'xlc_r'
     set CFLAGS = "-DIBM32 -D_32_BIT -O3"
     set CFLAGS = "$CFLAGS -qalias=ansi -qthreaded -qarch=auto"
     set CFLAGS = "$CFLAGS -qtune=auto  -qstrict -I./"
     set CLIBS  = "-lpthread"

     set F77_OPTS = "-DINT_SIZE=int -D_UNDERSCORES=0"

     set AR_FLAGS     = '-r -s -X 32'
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'xlf'
     set FORT_FLAGS = '-O2 -qarch=com -qflag=W:W -qhalt=W -qnosave'
     set FORT_LIBS  = ''
  endif


# ---------- #
# IBM 64-bit #
# ---------- #
  if($TARGET == ibm64 || $TARGET == ibm64-sp) then
     if (`uname` == AIX) then
                                  set CC = 'xlc_r'
        if($TARGET   == ibm64-sp) set CC = 'mpcc_r'
        set CFLAGS   = "-O3 -q64 -DIBM64"
        set CFLAGS   = "$CFLAGS -qalias=ansi -qthreaded -qarch=auto"
        set CFLAGS   = "$CFLAGS -qtune=auto  -qstrict -I./"
        set AR_FLAGS = '-r -s -X 64'
     else
        set CC       = 'gcc'
        set CFLAGS   = '-O2 -m64 -DIBM64 -I./'
        set AR_FLAGS = 'cr'
     endif

     set CLIBS    = "-lpthread"
     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=0"
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'xlf'
     if(`uname` == AIX) then
       set FORT_FLAGS = '-q64 -qintsize=8'
       set FORT_LIBS  = ' '
     else
       set FORT_FLAGS = '-q64 -qintsize=8'
       set FORT_LIBS  = '-lxlf90_r'
     endif
     if($TARGET == ibm64-sp) then
       set FORTRAN    = 'mpxlf_r'
       set FORT_FLAGS = '-O2 -q64 -qintsize=8 -qarch=pwr3 -qtune=pwr3 -qspillsize=1500 -qflag=W:W -qhalt=W -qnosave'
       set FORT_LIBS  = '-llapi_r'
     endif
  endif


# ------------- #
# IBM Blue Gene #
# ------------- #
#  IBM seems to put the compilers on the path, but not ar,
#  so the full path to that is given to it.
#
#  Note: if ARMCI is installed, DDI can be run using ARMCI as a
#  one-sided library, without data servers.  Installation of
#  ARMCI must have been performed already, you may need to check
#  the path name below for its include files.
#
#  This machine can run over MPI-1 with data servers (COMM=mpi),
#  if your Blue Gene does not have AMRCI installed.
#
#  This is a limited memory machine, so request a smaller buffer
#  for global sum than the default.
#
  if ($TARGET == ibm-bg) then
     set CFLAGS = "-O3 -DIBMBG -D_32_BIT -DDDI_BUFFER_SIZE=1048576"
     set CFLAGS = "$CFLAGS -qalias=ansi -qthreaded -qarch=auto"
     set CFLAGS = "$CFLAGS -qstrict -I./"

#            the old model uses ARMCI and the system's MPI
     if ($GMS_BG_MODEL == L) then
        set CC = 'blrts_xlc'
        set CFLAGS = "$CFLAGS -I/bgl/BlueLight/ppcfloor/bglsys/include"
        set CFLAGS = "$CFLAGS -I$GMS_ARMCI_PATH/src"
        set AR="/bgl/BlueLight/ppcfloor/blrts-gnu/bin/powerpc-bgl-blrts-gnu-ar"
     endif
#            The new model uses MPI only
     if ($GMS_BG_MODEL == P) then
        set CC = 'bgxlc_r'
        set CFLAGS = "$CFLAGS -I/bgsys/drivers/ppcfloor/comm/include"
        set CFLAGS = "$CFLAGS -I/bgsys/drivers/ppcfloor/arch/include"
        set AR="ar"
     endif

     set CLIBS  = ""

     set F77_OPTS = "-DINT_SIZE=int -D_UNDERSCORES=0"

     set AR_FLAGS     = '-cr'
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'mpixlf_r'   #?
     set FORT_FLAGS = '-O2 -qarch=440  -qflag=W:W -qhalt=W -qnosave '
     set FORT_LIBS  = ''
  endif


# ---------------------------------------- #
# Linux for 32 bit systems (Red Hat, etc.) #
# ---------------------------------------- #
#     see comments just above the Linux 64 bit clause just below.
#
  if($TARGET == linux32) then

     set FORTRAN=$GMS_FORTRAN   # might be g77, gfortran, ifort, pgf77, f2c

     set CC = 'gcc'
     set CFLAGS = "-DLINUX -O3 -fstrict-aliasing -I./"
     set CLIBS  = "-lpthread"

     switch ($FORTRAN)
        case g77:
        case pgf77:
        case f2c:
           set NumUS=2
           breaksw
        case gfortran:
           set CFLAGS = "$CFLAGS -Dgetarg_=_gfortran_getarg_i4"
           set CFLAGS = "$CFLAGS -Diargc_=_gfortran_iargc"
           set NumUS=1
           breaksw
        case ifort:
           set NumUS=1
           breaksw
        default:
           echo "Please spell your linux32 FORTRAN compiler correctly."
           exit 4
     endsw

     set F77_OPTS = "-DINT_SIZE=int -D_UNDERSCORES=$NumUS"

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '

     set FORT_FLAGS = '-O2'
     set FORT_LIBS = ' '
  endif

# ---------------------------------------------- #
# Linux for 64 bit PCs (both AMD and Intel chips #
# ---------------------------------------------- #
#       note that DDI is in C, so FORTRAN below is not used except for a
#       test program.  The compiler name also lets this script choose the
#       the number of trailing underscores needed, but more importantly,
#       deals with gfortran's use of names prefixed by _gfortran_ in its
#       library of FORTRAN callable routines.
#
#       Note that in all cases, we use the gcc compiler from GNU for
#       the compilation of DDI, even if a non-GNU FORTRAN is used.
#
  if($TARGET == linux64) then

     set FORTRAN=$GMS_FORTRAN   # might be gfortran, ifort, pgf77, pathf90
#
#        Itan2 does not allow -m32/-m64 flags, it's all 64 bit pointers.
#
                             set ARCH='-m64'
     if (`uname -p` == ia64) set ARCH=''

     set CC = 'gcc'
     set CFLAGS = "-DLINUX $ARCH -O3 -fstrict-aliasing -I./"
     set CLIBS  = "-lpthread"

     switch ($FORTRAN)
        case gfortran:
           set CFLAGS = "$CFLAGS -Dgetarg_=_gfortran_getarg_i4"
           set CFLAGS = "$CFLAGS -Diargc_=_gfortran_iargc"
           set NumUS=1
           set FORT_FLAGS = "-O2 $ARCH -fdefault-integer-8 -std=legacy"
           breaksw
        case pgf77:
           set NumUS=1
           set CFLAGS = "$CFLAGS -mcmodel=medium"
           set FORT_FLAGS = "-O2 $ARCH -i8 -i8storage -mcmodel=medium"
           breaksw
        case ifort:
           set NumUS=1
           set FORT_FLAGS = "-O2 -i8"
           breaksw
        case pathf90:
           set NumUS=2
           set FORT_FLAGS = "-O2 $ARCH -i8"
           breaksw
        default:
           echo "Please spell your linux64 FORTRAN compiler correctly."
           exit 4
     endsw

     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=$NumUS"

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '

     set FORT_LIBS = ' '
  endif


# ----------------------- #
# NEC SX vector processor #
# ----------------------- #
#    Caution!  This has not been tested, but rather it is an educated guess.
  if($TARGET == necsx) then
     set CC = 'c++'
     set CFLAGS = "-DNECSX -O -I./ -size_t64"
     set CLIBS  = "-lpthread"
     
     set F77_OPTS = '-DINT_SIZE=long -D_UNDERSCORES=1'

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '

     set FORTRAN    = 'f90'
     set FORT_FLAGS = '-ebw -size_t64 -Wf"-Nv"'
     set FORT_LIBS  = ''
  endif


# -------- #
# Mac OS X #
# -------- #
# OS X 10.1 will not work at all, 10.2 is primitive, 10.3 needs an edit below.
# for 64 bit mode, we need at least OS X 10.4, but >= 10.5 is more better.
#
  if (($TARGET == mac32) || ($TARGET == mac64)) then

     set FORTRAN=$GMS_FORTRAN       # will be g77 or gfortran

     set CC = 'gcc'
                           set CFLAGS = "-DMACOSX"
     if ($TARGET == mac64) set CFLAGS = "-DLINUX -m64"
     set CFLAGS = "$CFLAGS -O3 -fstrict-aliasing -I./"
     set CLIBS  = "-lpthread"

     #       uncomment next line for OS X 10.3
     #---set CFLAGS = "$CFLAGS -Dsocklen_t=int"

     switch ($FORTRAN)
        case g77:
           set NumUS=2
           set FORT_FLAGS = '-O2'
           set FORT_LIBS  = ''
           breaksw
        case gfortran:
           set CFLAGS = "$CFLAGS -Dgetarg_=_gfortran_getarg_i4"
           set CFLAGS = "$CFLAGS -Diargc_=_gfortran_iargc"
           set NumUS=1
           set FORT_FLAGS = '-O2 -m64 -fdefault-integer-8 -std=legacy'
           if ($TARGET == mac32) set FORT_FLAGS = '-O2 -std=legacy'
           set FORT_LIBS  = ''
           breaksw
        default:
           echo Your OS X FORTRAN compiler was not correctly specified.
           exit
           breaksw
     endsw

                          set F77_OPTS = "-DINT_SIZE=int"
     if($TARGET == mac64) set F77_OPTS = "-DINT_SIZE=long"
     set F77_OPTS = "$F77_OPTS -D_UNDERSCORES=$NumUS"

     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = '-c'

  endif


# ---------- #
# SGI 32-bit #
# ---------- #
  if($TARGET == sgi32) then
     set CC='cc'
     set CFLAGS='-DSGI32 -n32 -i4 -O -I./'
     set CLIBS='-lpthread'

     set F77_OPTS='-DINT_SIZE=int -D_UNDERSCORES=1'
     set AR_FLAGS='-cr'
     set RANLIB_FLAGS=' '

     set FORTRAN    = 'f77'
     set FORT_FLAGS = '-O2 -automatic -G0 -n32 -i4 -woff 136,2290' #?
     set FORT_LIBS  = ''

  endif


# ---------- #
# SGI 64-bit #
# ---------- #
#    There is a bit of trouble with the Origin:
#    The SHMEM option dies upon touching AO integral files
#    The Sockets option usually can't start 16 or more processes
#    The old version has to start data servers which are awkward on Origin
  if($TARGET == sgi64) then
     switch ($COMM)
        case shmem:
           echo "Compiling: ddio3k.o"
           #---set echo
           #---f77 -O2 -automatic -G0 -64 -i8 -woff 2290 -c shmem/ddio3k.f
           #---unset echo
           ../comp ddio3k

           if(-e ddio3k.o) then
              ar -cr libddi.a ddio3k.o
              rm -f ddio3k.o
              echo "Finished compiling: ddio3k.o"
              goto finishOK
           else
              echo "Error compiling: ddio3k.o"
              exit 4
           endif
           breaksw
        case sockets:
           set CC = 'cc -64 -mips4'
           set CFLAGS = '-DSGI64 -O -I./'
           set CLIBS='-lpthread'
           set F77_OPTS='-DINT_SIZE=long -D_UNDERSCORES=1'
           set AR_FLAGS     = '-cr'
           set RANLIB_FLAGS = '-c'
           breaksw
        default:
           echo SGI 64 bits requires COMM of sockets or shmem.
           exit 3
           breaksw
     endsw

     set FORTRAN    = 'f77'
     set FORT_FLAGS = '-O2 -automatic -G0 -64 -i8 -woff 136,2290' #?
     set FORT_LIBS  = ''

  endif


# ---------- #
# Sun 32-bit #
# ---------- #
  if($TARGET == sun32) then

     if(`uname -p` == sparc) set ARCH='-xarch=v8plus'
     if(`uname -p` == i386)  set ARCH='-xarch=pentium_pro'

     set CC = 'cc'
     set CFLAGS = "$ARCH -DSUN32 -O -Dsocklen_t=int -D_32_BIT -I./"
     set CLIBS  = "-lsocket -lnsl -lpthread"

     set F77_OPTS = "-DINT_SIZE=int -D_UNDERSCORES=1"

     set AR_FLAGS     = '-cr'
     set RANLIB_FLAGS = '-c'

     set FORTRAN    = $GMS_FORTRAN
     if ($FORTRAN == f77) set FORT_FLAGS = "$ARCH -O2"
     if ($FORTRAN == f90) set FORT_FLAGS = "$ARCH -O2 -xtypemap=integer:32"
     set FORT_LIBS="-lsocket -lnsl -lpthread"

  endif


# ---------- #
# Sun 64-bit #
# ---------- #
  if($TARGET == sun64) then
#         define ARCH, compilers after v 8.3 should say the simple -m64
     set xxx=$GMS_SUN_FORT_VERNO
     set f90_major=$xxx:r
     set f90_minor=$xxx:e
                                                 set newf90=false
     if (($f90_major == 8) && ($f90_minor >= 3)) set newf90=true
     if  ($f90_major >= 9)                       set newf90=true

     if ($newf90 == true) then
        set ARCH=-m64
     else
        if (`uname -p` == sparc) set ARCH='-xarch=v9'
        if (`uname -p` == i386)  set ARCH='-xarch=amd64'
     endif
#         so now ARCH is finally defined (used by both C and FORTRAN)

     set CC = 'cc'
     set CFLAGS = "$ARCH -DSUN64 -O -I./"
     set CLIBS  = '-lsocket -lnsl -lpthread'

     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=1"

     set AR_FLAGS     = '-cr'
     set RANLIB_FLAGS = '-c'

     set FORTRAN = 'f90'
     set FORT_FLAGS="$ARCH -O2 -xtypemap=integer:64"
     set FORT_LIBS="-lsocket -lnsl -lpthread"
  endif

# ----------------- #
# Microsoft Windows #
# ----------------- #
# Currently with only PGI compiler support.

  if($TARGET == win32) then

     set FORTRAN=pgf77     # choose from pgf77

     switch ($FORTRAN)
        case pgf77:
           set CC = 'pgcc'
#
#          For more detailed information as to which flags are being used
#          by the compiler during the build - uncomment the line below.
#
           set CC = "$CC -v"
#
           set CFLAGS = '-DLINUX -DWINDOWS -DUSE_DDI_COLLECTIVE_ROUTINES -DOLDDDITIMER'
           if ($GMS_WIN_OPT == baseline)    set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -O0"
           if ($GMS_WIN_OPT == linux)       set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -O3"
           if ($GMS_WIN_OPT == fast)        set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -fast"
           if ($GMS_WIN_OPT == testing)     set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -fast $GMS_WIN_FLAGS"
           set CFLAGS = "$CFLAGS $GMS_WIN_TP -I./include"
           set NumUS=2
           if ($COMM == mpi) then
             echo "----------------------------------------------   ATTENTION   ----------------------------------------------"
             echo "- We are using MPI and not TCP/IP sockets so please ignore the following compiler warning message:        -"
             echo "- libddi.a(tcp_sockets.o) : warning LNK####: no public symbols found; archive member will be inaccessible -"
             echo "-----------------------------------------------------------------------------------------------------------"
           endif
           breaksw
        default:
           echo "Please spell your win32 bit FORTRAN compiler name correctly."
           exit 4
     endsw
     set CLIBS  = ' '
     set F77_OPTS = "-DINT_SIZE=int -D_UNDERSCORES=$NumUS"
     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '
  endif

  if($TARGET == win64) then

     set FORTRAN=pgf77     # choose from pgf77

     switch ($FORTRAN)
        case pgf77:
           set CC = 'pgcc'
#
#          For more detailed information as to which flags are being used
#          by the compiler during the build - uncomment the line below.
#
           set CC = "$CC -v"
#
           set CFLAGS = '-DLINUX -DWINDOWS -DWINDOWS64 -DUSE_DDI_COLLECTIVE_ROUTINES -DOLDDDITIMER'
#          set CFLAGS = '-DLINUX -DWINDOWS -DWINDOWS64 -DOLDDDITIMER'
           if ($GMS_WIN_OPT == baseline)    set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -O0"
           if ($GMS_WIN_OPT == linux)       set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -O2"
           if ($GMS_WIN_OPT == fast)        set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -fast"
           if ($GMS_WIN_OPT == testing)     set CFLAGS = "$CFLAGS -Bstatic -Minform=severe -fast $GMS_WIN_FLAGS"
           set CFLAGS = "$CFLAGS $GMS_WIN_TP -I./include"
           set NumUS=1
           if ($COMM == mpi) then
             echo "----------------------------------------------   ATTENTION   ----------------------------------------------"
             echo "- We are using MPI and not TCP/IP sockets so please ignore the following compiler warning message:        -"
             echo "- libddi.a(tcp_sockets.o) : warning LNK####: no public symbols found; archive member will be inaccessible -"
             echo "-----------------------------------------------------------------------------------------------------------"
           endif
           breaksw
        default:
           echo "Please spell your win64 bit FORTRAN compiler name correctly."
           exit 4
     endsw
     set CLIBS  = ' '
     set F77_OPTS = "-DINT_SIZE=__int64 -D_UNDERSCORES=$NumUS $GMS_WIN_FLAGS"
     set AR_FLAGS     = 'cr'
     set RANLIB_FLAGS = ' '
  endif

#            this is how we trap for an unsupported machine.
  if ($?CFLAGS) then
  else
    echo The compddi script does not select a correct TARGET machine type.
    echo What you typed when editing this script was $TARGET
    exit 4
  endif

# ------------- end of machine specific option selection -------------- #


  echo Attempting to remove binary files from previous DDI build...
                               rm -f src/*.o 
  if (-e libddi.a)             rm -f libddi.a
  if (-e kickoff/libddikick.a) rm -f kickoff/libddikick.a
  if (-e ddikick.x)            rm -f ddikick.x 
  if (-e ddi_test.x)           rm -f ddi_test.x
  if (-e ddi_server.x)         rm -f ddi_server.x
  echo " "
  echo Beginning the DDI compilation at `date`
  echo " "

# --------------------------------------------------- #
# append the MPI include path to the C compiler flags
# --------------------------------------------------- #
  if($COMM == mixed) set CFLAGS = "$CFLAGS -I$MPI_INCLUDE_PATH"
  if($COMM == mpi)   then
     switch ($GMS_MPI_LIB)
        case msmpi:
           set CFLAGS = "$CFLAGS -Mmpi=msmpi"
           breaksw
        case Cray-XT-MPI:
        case IBM-BlueGene-MPI:
           breaksw
        default:
           set CFLAGS = "$CFLAGS -I$MPI_INCLUDE_PATH"
           breaksw
     endsw
  endif


  if($DDI_SOURCE == old) goto old


# ---------------------- #
# Compile common objects #
# ---------------------- #
#   In this context, common means the TCP/IP kickoff program
#   will also be using this code, so save into its library too.
#
#   Here and elsewhere, Microsoft Windows requires -o to name object files
#
  chdir src
  foreach OBJ ( soc_create      std_system     tcp_sockets   \
                debug           parse_node_args              \
              )
    echo "Compiling common object: $OBJ.o"
    set echo
    $CC $CFLAGS $DDI_OPTS -o $OBJ.o -c $OBJ.c
    unset echo
    if(-e $OBJ.o) then
       echo "Finished compiling: $OBJ.o"
    else
       echo "Error compiling: $OBJ.o"
       goto bombout
    endif
    ar $AR_FLAGS ../libddi.a   $OBJ.o
    if($COMM == sockets) ar $AR_FLAGS ../kickoff/libddikick.a  $OBJ.o
    echo " "
  end
  chdir ..

# ------------------- #
# Compile DDI objects #
# ------------------- #
#   The bulk of the DDI library:
  chdir src
  set OBJ_LIST=(ddi            ddi_send        ddi_recv        \
                ddi_get        ddi_put         ddi_acc         \
                ddi_getacc     ddi_distrib     \
                ddi_subpatch   ddi_index       ddi_recvany     \
                ddi_create     ddi_destroy     ddi_server      \
                ddi_finalize   ddi_memory      ddi_lapi        \
                ddi_isend      ddi_irecv       ddi_wait        \
                ddi_signals    ddi_id          ddi_timer       \
                ddi_gdlb       ddi_dlb         ddi_dlb_proc    \
                ddi_init       sysv_ipc       \
                ddi_comm       ddi_comm_group  ddi_comm_send   \
                ddi_comm_recv  ddi_comm_sync   ddi_comm_gsum   \
                ddi_comm_bcast ddi_smp         ddi_comm_create \
                ddi_comm_nproc ddi_comm_nnode \
                ddi_runtime     \
                ddi_util       mmath          \
                ddi_arr        ddi_arr_acc     ddi_arr_add     \
                ddi_arr_dot    ddi_arr_scalar  ddi_arr_select  )

  # ARMCI objects
  if ($COMM == armci) then
    set OBJ_LIST=($OBJ_LIST     \
                ddi_armci      ddi_armci_init  ddi_armci_acc  \
                ddi_armci_get  ddi_armci_put   ddi_armci_getacc)
  endif

  # Blue Gene objects
  if ($TARGET == ibm-bg) then
    if ($GMS_BG_MODEL == L) set OBJ_LIST=($OBJ_LIST ddi_bgl)
    if ($GMS_BG_MODEL == P) set OBJ_LIST=($OBJ_LIST ddi_bgp)
  endif

  # Microsoft Windows objects
  if (($TARGET == win32) || ($TARGET == win64)) then
    set OBJ_LIST=($OBJ_LIST windows)
  endif

  foreach OBJ ($OBJ_LIST) 
    echo "Compiling DDI object: $OBJ.o"
    set echo
    $CC $CFLAGS $DDI_OPTS -o $OBJ.o -c $OBJ.c
    unset echo
    if(-e $OBJ.o) then
       echo "Finished compiling: $OBJ.o"
    else
       echo "Error compiling: $OBJ.o"
       goto bombout
    endif
    ar $AR_FLAGS ../libddi.a  $OBJ.o
    echo " "
  end 
  chdir ..
 

# ------------------------ #
# Compile FORTRAN Wrappers #
# ------------------------ #
  chdir src
  echo "Compiling FORTRAN wrappers for DDI"
  set echo
  $CC $CFLAGS $DDI_OPTS $F77_OPTS -o ddi_fortran.o -c ddi_fortran.c
  unset echo
  if(-e ddi_fortran.o) then
     echo "Finished compiling: ddi_fortran.o"
  else
     echo "Error compiling: ddi_fortran.o"
     goto bombout
  endif
  ar $AR_FLAGS ../libddi.a  ddi_fortran.o
  echo " "
  chdir ..


# ------------------------ #
# Compile DDI test program #
# ------------------------ #
#      the test program should work over other communication libraries,
#      such as MPI-1, but for now we create it only for the very easy
#      case of TCP/IP.
#      We would need to add MPI library lists (not just an MPI include path)
#      to this script, in order to correctly build the test program.
#      That is postponed to some other time!
  if($COMM == sockets) then
     chdir test
     echo "Creating DDI test program, ddi_test.x"
     set echo
     $FORTRAN $FORT_FLAGS -o ../ddi_test.x ddi_test.f \
                    ../libddi.a $FORT_LIBS $CLIBS
     unset echo
     if (-e ddi_test.o) rm -f ddi_test.o
     echo " "
     chdir ..
  endif


# --------------------------- #
# Compile data_server program #
# --------------------------- #
#    This program is not used by GAMESS, which acts as its own data server,
#    but might be useful if one wants a light-weight data server.
#    This program is in principle usable with MPI-1, but we have not yet
#    done the scripting to add all the MPI library possibilities here.
  if($COMM == sockets) then
     chdir server
     echo "Creating standalone DDI data server program, data_server.x"
     set echo
     $CC $CFLAGS $DDI_OPTS -I../src -o ../data_server.x data_server.c \
                    ../libddi.a $CLIBS
     unset echo
     rm -f data_server.o
     echo " "
     chdir ..
  endif


# ------------------------------------------------------ #
# Compile DDIKICK objects, and then link kickoff program #
# ------------------------------------------------------ #
#     The reason for not inserting a "mv ddikick.x .." command in
#     this script is for situations when rebuilding the library is
#     done later, when one might not want to erase the previous
#     ddikick.x (i.e. if GAMESS jobs are running at the moment).
#
#     note that some of the routines called by ddikick.x
#     have already been compiled above, and saved in
#     the kickoff program's library file.
  if($COMM == sockets) then
     chdir kickoff
     echo "TCP/IP communications uses a special kickoff program, ddikick.x"
     echo " "
     foreach OBJ ( ddikick        ddikick_error  accept_tasks   \
                   finalize_tasks kickoff_local  kickoff_remote \
                   kickoff_pbs \
                 )
       echo "Compiling ddikick object: $OBJ.o"
       set echo
       $CC $CFLAGS $DDI_OPTS -I../src -c $OBJ.c
       unset echo
       if(-e $OBJ.o) then
          echo "Finished compiling: $OBJ.o"
       else
          echo "Error compiling: $OBJ.o"
          goto bombout
       endif
       if ($OBJ != ddikick) ar $AR_FLAGS libddikick.a  $OBJ.o
       echo " "
     end
     #
     ranlib $RANLIB_FLAGS libddikick.a
     #
     echo "Linking DDI kickoff program, ddikick.x"
     set echo
     $CC $CFLAGS $DDI_OPTS -o ../ddikick.x ddikick.o libddikick.a $CLIBS
     unset echo
     echo " "
     echo "Don't forget to move ddikick.x up one directory level,"
     echo "by a   'mv ddikick.x ..'   command."
     echo " "
     rm -f *.o libddikick.a
     chdir ..
  endif


# --------------------------- #
# Compile OLD DDI source code #
# --------------------------- #
old:
  if($DDI_SOURCE == old) then
      chdir oldsrc
      # ddisoc.c
        echo "Compiling: ddisoc.o"
        set echo
        $CC $CFLAGS -c ddisoc.c
        unset echo
        if(-e ddisoc.o) then
           echo "Finished compiling: ddisoc.o"
        else
           echo "Error compiling: ddisoc.c"
           goto bombout
        endif
        ar $AR_FLAGS ../libddi.a  ddisoc.o
        echo ""

      # ddi.src
        echo "Compiling: ddi.o"
        $FORTRAN $FORT_FLAGS -c ddi.f
        if(-e ddi.o) then
           echo "Finished compiling: ddi.o"
        else 
           echo "Error compiling: ddi.o"
           goto bombout
        endif
        ar $AR_FLAGS ../libddi.a ddi.o
        rm -f ddi.o
        echo ""

      # ddikick.x
        if(-e ../ddikick.x) rm -f ../ddikick.x
        echo "Compiling: ddikick.x"
        set echo
        $CC $CFLAGS $DDI_OPTS -o ../ddikick.x ddikick.c $CLIBS
        unset echo
        echo ""
      chdir ..
  endif
 

# ------------------------------------------------------------ #
# End of compile script, run "ranlib" on the library and exit. #
# ------------------------------------------------------------ #
finishOK:

#   SGI's IRIX has its ranlib built into its ar command (very rational)
  if (($TARGET != sgi64) && ($TARGET != sgi32)) then
     ranlib $RANLIB_FLAGS libddi.a
  endif

  echo "DDI compilation ended successfully."
  rm -f src/*.o
  date
  time
  exit

#    if something bad happens, remove all binary files,
#    to make sure the user realizes compddi crashed out.
bombout:
  echo " "
  echo "DDI compilation did not finish correctly, please fix, and try again"
  echo " "
  chdir ..
  if (-e libddi.a)             rm -f libddi.a
  if (-e kickoff/libddikick.a) rm -f kickoff/libddikick.a
  if (-e ddikick.x)            rm -f ddikick.x
  if (-e ddi_test.x)           rm -f ddi_test.x
  if (-e ddi_server.x)         rm -f ddi_server.x
  rm -f src/*.o
  rm -f kickoff/*.o
  rm -f test/*.o
  rm -f server/*.o
  date
  time
  exit 8

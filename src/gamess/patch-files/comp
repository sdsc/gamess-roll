#!/bin/csh -f
#
#  11 August 11 - script to compile one GAMESS source file
#  Invoke this script by './comp MODULE >& MODULE.log &'.
#
#  This script no longer requires customization, as it starts off by
#  reading information about the compilation from a configuration file.
#
if (-e install.info) then
   source install.info
else if (-e ../install.info) then
   source ../install.info
else
   echo "Please run 'config' first, to set up GAMESS compiling information"
   exit 4
endif
#
#  the configuration file read just above provides the next two variables,
#  and possibly several other GMS_XXX values that may be used below.
#
set TARGET=$GMS_TARGET
chdir $GMS_PATH
#
#        allow for "dry run" that doesn't actually do anything
#
if ($?GMS_COMP_DRYRUN) then
   echo $0 $argv
   exit 0
endif
#
#        allow for extra debugging flags
#
if ($?GMS_DEBUG_FLAGS) then
   if (! -d tmp) mkdir tmp
else
   set GMS_DEBUG_FLAGS=''
endif
#
#        make sure any exotic variable touched below is not an error
#
if (!($?GMS_BG_MODEL)) set GMS_BG_MODEL=' '
#
#    ---- and now the script begins...
#
unset echo
set MODULE=$1
set ACTONLY=$2   # this argument is almost always omitted
if (null$MODULE == null) then
   echo No compile module name given...
   exit
endif
#
echo ======================== $MODULE ==============================
date
#
#   Let's be sure they typed the intended target correctly
#
#   This also serves as a full list of compiler clauses allowed in
#   this script, some of which are hidden by the gms-config.  For
#   example, there are a number of ancient Cray products below,
#   and the NEC and Fujitsu products probably aren't well tested.
#
set OK=false
if ($TARGET == axp64)      set OK=true
if ($TARGET == cray-pvp)   set OK=true
if ($TARGET == cray-t3e)   set OK=true
if ($TARGET == cray-x1)    set OK=true
if ($TARGET == cray-xd1)   set OK=true
if ($TARGET == cray-xt)    set OK=true
if ($TARGET == fuji-pp32)  set OK=true
if ($TARGET == fuji-pp64)  set OK=true
if ($TARGET == hpux32)     set OK=true
if ($TARGET == hpux64)     set OK=true
if ($TARGET == ibm32)      set OK=true
if ($TARGET == ibm64)      set OK=true
if ($TARGET == ibm64-sp)   set OK=true
if ($TARGET == ibm-bg)     set OK=true
if ($TARGET == linux32)    set OK=true
if ($TARGET == linux64)    set OK=true
if ($TARGET == mac32)      set OK=true
if ($TARGET == mac64)      set OK=true
if ($TARGET == necsx)      set OK=true
if ($TARGET == sgi32)      set OK=true
if ($TARGET == sgi64)      set OK=true
if ($TARGET == sun32)      set OK=true
if ($TARGET == sun64)      set OK=true
if ($TARGET == win32)      set OK=true
if ($TARGET == win64)      set OK=true
if ($OK == false) then
   echo The comp script does not select a correct TARGET machine type.
   echo What you typed when editing this script was $TARGET
   exit 4
endif
#
#   ----- Is this a vector machine? -----
#
set VECTORIZE=false
if ($TARGET == cray-pvp) set VECTORIZE=true
if ($TARGET == cray-x1)  set VECTORIZE=true
if ($TARGET == necsx)    set VECTORIZE=true
#
#   ----- Are level 3 BLAS in a system library? -----
#   If so, some matrix multiplies in MTHLIB.SRC can use DGEMM calls
#   If not, print a warning to try to get people to find a BLAS library.
#
#   N.B.  Machines that use vector.src accomplish this business in a
#   different manner, so ignore this part.
#
set BLAS3=false
if ($MODULE == mthlib) then
#
if (($TARGET == axp64)  && \
    ((-e /usr/lib/libdxml.a)||(-e /usr/lib/libcxml.a))) set BLAS3=true
if  ($TARGET == cray-t3e)     set BLAS3=true
if  ($TARGET == cray-x1)      set BLAS3=true
if  ($TARGET == cray-xt)      set BLAS3=true
if  ($TARGET == cray-xd1) then
    if (-e $ACML_DIR) set BLAS3=true
    if (-e $PGI/linux86-64/$PGI_VERS_STR/lib/libblas.a) set BLAS3=true
endif
if  ($TARGET == fuji-pp32)    set BLAS3=true
if  ($TARGET == fuji-pp64)    set BLAS3=true
if  ($TARGET == hpux32)       set BLAS3=true
if  ($TARGET == hpux64)       set BLAS3=true
if  ($TARGET == ibm32)        set BLAS3=true
if  ($TARGET == ibm64)        set BLAS3=true
if  ($TARGET == ibm64-sp)     set BLAS3=true
if  ($TARGET == ibm-bg)       set BLAS3=true
if (($TARGET == linux32) && ($GMS_MATHLIB != none)) set BLAS3=true
if (($TARGET == linux64) && ($GMS_MATHLIB != none)) set BLAS3=true
if  ($TARGET == mac32)        set BLAS3=true
if  ($TARGET == mac64)        set BLAS3=true
if  ($TARGET == sgi32)        set BLAS3=true
if  ($TARGET == sgi64)        set BLAS3=true
if (($TARGET == sun32) && (-e /opt/SUNWspro/lib/libsunperf.so)) set BLAS3=true
if (($TARGET == sun64) && (-e /opt/SUNWspro/lib/libsunperf.so)) set BLAS3=true
if  ($TARGET == win32) then
   if (-e $PGI\\win32\\11.7\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\11.6\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\11.1\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\11.0\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\10.8\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\10.6\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\10.4\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\10.3\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win32\\10.2\\lib\\libblas.lib) set BLAS3=true
endif
if  ($TARGET == win64) then
   if (-e $PGI\\win64\\11.7\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\11.6\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\11.1\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\11.0\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\10.8\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\10.6\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\10.4\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\10.3\\lib\\libblas.lib) set BLAS3=true
   if (-e $PGI\\win64\\10.2\\lib\\libblas.lib) set BLAS3=true
endif
#
if ($BLAS3 == true) then
  echo Compiling matrix multiply routines to use a system BLAS library...
else
  echo "--------------------------------------------------------------"
  echo '        Warning\!  Warning\!  Warning\!  Warning\!'
  echo "No mathematical library containing the BLAS has been detected."
  echo "Use of a DGEMM from a good library will speed up computations"
  echo "at the MP2, CCSD, or similar correlated levels, perhaps a lot."
  echo "In the meantime, mthlib.src and all other calls to DGEMM will"
  echo "rely on the slower blas.src provided with GAMESS."
  echo "--------------------------------------------------------------"
endif
endif
#
#        Normally we are sitting above the source code and objects,
#        and want to make sure they go in their normal directory.
#
#        N.B.  A few places below prepare temporary copies of the
#        code being compiled in the current directory level (.),
#        and these are always deleted at the end of this script.
#        These places are vector, valence bond, and sed hacking.
#
set SRCDIR=source
set OBJDIR=object
#
#        a few source files are kept in non-standard places, defined here
#        there is a secret option to store code other than in 'source'.
#
if ($MODULE == blaswrap) set SRCDIR=misc
if ($MODULE == serial)   set SRCDIR=misc
if ($MODULE == ddi)      set SRCDIR=ddi/oldddi/v1
if ($MODULE == ddishm)   set SRCDIR=ddi/oldddi/shmem
if ($MODULE == ddit3e)   set SRCDIR=ddi/oldddi/shmem
if ($MODULE == ddio3k)   set SRCDIR=ddi/oldddi/shmem
if ($MODULE == ddixt3)   set SRCDIR=ddi/oldddi/shmem
if ($?GMS_OTHER_SRCDIR) then
    set SRCDIR=$GMS_OTHER_SRCDIR
endif
#
#   ----- delete scalar code before compiling on vector systems -----
#   UNIX's 'ld' loader is incapable of loading two copies of the
#   object code for a routine, and simply using the first one.
#   So, if we are using VECTOR.SRC on this machine, we must split
#   up some of the modules, delete the scalar code for the routines
#   which are found in VECTOR.SRC, and then recombine the rest of
#   the code in that module.  Ugh!
#   Note that some of Cray's fsplit's are no longer able to work
#   with any extension except .f.
#
if ($VECTORIZE == true) then
   rm -f *.f
   if ($TARGET == cray-x1) alias fsplit ftnsplit
   switch ($MODULE)
      case int2a:
         echo Deleting scalar code forms, genral
         cp source/int2a.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e forms.f) rm -f forms.f genral.f
         if (-e FORMS.f) rm -f FORMS.f GENRAL.f
         cat *.f > int2a.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      case grd2c:
         echo Deleting scalar code dspdfv, jdxyzv, jkgnmv, jkxyzv
         cp source/grd2c.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e dspdfv.f) rm -f dspdfv.f jdxyzv.f jkgnmv.f jkxyzv.f
         if (-e DSPDFV.f) rm -f DSPDFV.f JDXYZV.f JKGNMV.f JKXYZV.f
         cat *.f > grd2c.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      case hss2b:
         echo Deleting scalar code jddspd.f
         cp source/hss2b.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e jddspd.f) rm -f jddspd.f
         if (-e JDDSPD.f) rm -f JDDSPD.f
         cat *.f > hss2b.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      case eigen:
         echo Deleting scalar code gldiag.f
         cp source/eigen.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e gldiag.f) rm -f gldiag.f
         if (-e GLDIAG.f) rm -f GLDIAG.f
         cat *.f > eigen.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      case mthlib:
         echo Deleting scalar code mtarbr, tfsqb, tftri.
         cp source/mthlib.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e mtarbr.f) rm -f mtarbr.f tfsqb.f tftri.f
         if (-e MTARBR.f) rm -f MTARBR.f TFSQB.f TFTRI.f
         cat *.f > mthlib.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      case scflib:
         echo Deleting scalar code dirfck.
         cp source/scflib.src xxxxxx.f
         fsplit xxxxxx.f
         rm -f xxxxxx.f
         if (-e dirfck.f) rm -f dirfck.f
         if (-e DIRFCK.f) rm -f DIRFCK.f
         cat *.f > scflib.src
         rm -f *.f
         set SRCDIR=.
         breaksw
      default:
         breaksw
   endsw
endif
#
#        optional SIMOMM method using Tinker MM program
#        if you do select this option, also set the number of MM atoms in
#        the following line to match your choice in Tinker's sizes.i file
#
set TINKER=false
set NumTinkAtms=12000
#
#        don't edit anything about Tinker below this point...
set TINKCODE=no
if ($MODULE == Libtad)  set TINKCODE=yes
if ($MODULE == Libteac) set TINKCODE=yes
if ($MODULE == Libtedl) set TINKCODE=yes
if ($MODULE == Libtemo) set TINKCODE=yes
if ($MODULE == Libterx) set TINKCODE=yes
if ($MODULE == Libtfi)  set TINKCODE=yes
if ($MODULE == Libtjo)  set TINKCODE=yes
if ($MODULE == Libtpr)  set TINKCODE=yes
if ($MODULE == Libtsx)  set TINKCODE=yes
if ($MODULE == Tdrive)  set TINKCODE=yes
if ($MODULE == Tinkin)  set TINKCODE=yes
if ($MODULE == Toys)    set TINKCODE=yes
#       We must compile directly out of the Tinker directory,
#       so that its INCLUDE statements will work.
#       Note that Tinker must also skip the code deletion at end!
if ($TINKCODE == yes) then
   chdir tinker
   set SRCDIR=.
   set OBJDIR=../object
   goto cmp
endif
#
#        optional Valence Band method using VB2000
#        Do Not Edit the "VB2000" value,
#        but you may need to edit the variable VBPATH just below.
set VB2000=false
if ($MODULE == vb2000) set VB2000=true
if ($MODULE == vb2gms) set VB2000=true
#        compiling in the top level directory means code is erased later
if ($VB2000 == true ) then
   set VBPATH=~/VB2000/SRC
   echo Copying $MODULE.src from VB2000 directory named $VBPATH
   set SRCDIR=.
   if ($MODULE == vb2000) then
#        Some messy sed stuff to set up.
      sed "s/^CTMAP/     /g" $VBPATH/vb2000.src | \
      sed "s/^CGMS/    /g"  > vb2000.src
   endif
   if ($MODULE == vb2gms) cp $VBPATH/vb2gms.src .
endif
#
#        Nuclear Electronic Orbital (NEO) method plugin
#             Do not edit here
#             == === ==== ====
#        If NEO is required, edit compall and lked, but not this file!
#
set NEOCMP=false
if ($MODULE =~ neo*)   set NEOCMP=true
if ($MODULE == neostb) set NEOCMP=false
if ($NEOCMP == true && $ACTONLY != true) set SRCDIR=qmnuc/neo
#
#   ----- Does this module need to be activated? -----
#
#   Machines where "DOUBLE PRECISION" translates to more than a 64
#   bit floating point quantity must be passed into the activation
#   to ensure the source is made single precision.
#
if ($TARGET == cray-pvp) goto act
if ($TARGET == cray-t3e) goto act
if ($TARGET == cray-x1)  goto act
if ($TARGET == necsx)    goto act
#
#   Machines needing the 64->32 bit BLAS wrappers must activate everything
#   This depends on whether or not the BLAS library is OK with 64 bit
#   integers in its argument, or not (in which case a sed hack to use
#   a 64 to 32 bit wrapper file is needed, by always branching here).
#
if ($TARGET == fuji-pp64) goto act
if ($TARGET == ibm64)     goto act
if ($TARGET == ibm-bg)    goto act
if ($TARGET == ibm64-sp)  goto act
if ($TARGET == mac64)     goto act
if ($TARGET == sgi64)     goto act
if ($TARGET == sun64)     goto act
#
#   Any module with machine dependent code must be activated...
#
if ($MODULE == aldeci) goto act
if ($MODULE == ccsdt)  goto act
if ($MODULE == cisgrd) goto act
if ($MODULE == cphf)   goto act
if ($MODULE == cpmchf) goto act
if ($MODULE == cprohf) goto act
if ($MODULE == dcint2) goto act
if ($MODULE == dcmp2)  goto act
if ($MODULE == dctran) goto act
if ($MODULE == ddi)    goto act
if ($MODULE == ddit3e) goto act
if ($MODULE == dft)    goto act
if ($MODULE == dftint) goto act
if ($MODULE == efpaul) goto act
if ($MODULE == eftei)  goto act
if ($MODULE == elgscf) goto act
if ($MODULE == fmogrd) goto act
if ($MODULE == gmcpt)  goto act
if ($MODULE == grd2a)  goto act
if ($MODULE == gugdga) goto act
if ($MODULE == gugdgb) goto act
if ($MODULE == gugdm2) goto act
if ($MODULE == gugem)  goto act
if ($MODULE == gugsrt) goto act
if ($MODULE == gvb)    goto act
if ($MODULE == gvvpt2) goto act
if ($MODULE == hss2a)  goto act
if ($MODULE == inputa) goto act
if ($MODULE == inputb) goto act
if ($MODULE == int2a)  goto act
if ($MODULE == iolib)  goto act
if ($MODULE == ivocas) goto act
if ($MODULE == lagran) goto act
if ($MODULE == local)  goto act
if ($MODULE == locpol) goto act
if ($MODULE == mccas)  goto act
if ($MODULE == mcqdpt) goto act
if ($MODULE == mcqud)  goto act
if ($MODULE == mcscf)  goto act
if ($MODULE == mctwo)  goto act
if ($MODULE == morokm) goto act
if ($MODULE == mp2)    goto act
if ($MODULE == mp2grd) goto act
if ($MODULE =~ neo*)   goto act
if ($MODULE == nmr)    goto act
if ($MODULE == ordint) goto act
if ($MODULE == qmmm)   goto act
if ($MODULE == rhfuhf) goto act
if ($MODULE == rohfcc) goto act
if ($MODULE == sfdft)  goto act
if ($MODULE == tddint) goto act
if ($MODULE == tdhf)   goto act
if ($MODULE == trans)  goto act
if ($MODULE == trfdm2) goto act
if ($MODULE == unport) goto act
if ($MODULE == utddft) goto act
if ($MODULE == vb2gms) goto act
if ($MODULE == vector) goto act
if ($MODULE == xmvb)   goto act
#
#   We may need to do a hack below on the matrix multiply routines
#
if (($BLAS3 == true) && ($MODULE == mthlib)) goto act
#
#   All other modules are straight FORTRAN, just copy them.
#
echo Copying source code, $MODULE.src does not require activation.
cp $SRCDIR/$MODULE.src $MODULE.f
goto cmp
#
#   ----- Choose which version is to be activated -----
#   The setting for 'ddi' applies to the possible use of the first version
#   of the Distributed Data Interface, and probably should be sockets only.
#   Most machines use the 2nd version of DDI, implemented entirely in C,
#   and compiled by the separate 'compddi' script.
#   In contrast, machines using the SHMEM library will compile a
#   confusing mixture of old SHMEM support files (see their readme).
#
act:
#
if ($TARGET == axp64) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*DEC'
endif
#       the old Cray vector systems would use TCP/IP sockets in DDI
if ($TARGET == cray-pvp) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*CRY'
   if ($MODULE == vector) setenv MACHIN '*CRY'
endif
#       the CRAY T3E has a special SHMEM implementation of DDI
if ($TARGET == cray-t3e) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddit3e) setenv MACHIN '*T3E'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*T3E'
endif
#       the CRAY X1 has a special SHMEM implementation of DDI
if ($TARGET == cray-x1) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddit3e) setenv MACHIN '*CX1'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*CX1'
   if ($MODULE == vector) setenv MACHIN '*CRY'
endif
#       the CRAY XD1 uses TCP/IP sockets, until GPSHMEM is working
if ($TARGET == cray-xd1) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddit3e) setenv MACHIN '*XD1'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*L64'
endif
#       the CRAY XT is using pure MPI, from the standard DDI version
if ($TARGET == cray-xt) then
                          setenv MACHIN '*I64'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*L64'
endif
if (($TARGET == fuji-pp32) || ($TARGET == fuji-pp64)) then
                             setenv MACHIN '*I32'
   if ($TARGET == fuji-pp64) setenv MACHIN '*I64'
   if ($MODULE == ddi)       setenv MACHIN '*SOC'
   if ($MODULE == iolib)     setenv MACHIN '*UNX'
   if ($MODULE == unport)    setenv MACHIN '*SUN'
endif
if (($TARGET == hpux32) || ($TARGET == hpux64)) then
                          setenv MACHIN '*I32'
   if ($TARGET == hpux64) setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*HP '
endif
if (($TARGET == ibm32) || ($TARGET == ibm64) || ($TARGET == ibm64-sp)) then
                          setenv MACHIN '*I64'
   if ($TARGET == ibm32)  setenv MACHIN '*I32'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*AIX'
endif
#
if ($TARGET == ibm-bg) then
                          setenv MACHIN '*I32'
   if ($MODULE == ddi)    setenv MACHIN '*MPI'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*AIX'
endif
#
if ($TARGET == linux32) then
                          setenv MACHIN '*I32'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*L32'
endif
#
if ($TARGET == linux64) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) then
      if ($GMS_FORTRAN == ifort) then
         setenv MACHIN '*INT'
      else
         setenv MACHIN '*L64'
      endif
   endif
endif
#
if ($TARGET == mac32) then
                          setenv MACHIN '*I32'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*L32'
endif
if ($TARGET == mac64) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*L64'
endif
#
if ($TARGET == necsx) then
                          setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*MPI'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*NEC'
   if ($MODULE == vector) setenv MACHIN '*NEC'
endif
#
if (($TARGET == sgi32) || ($TARGET == sgi64)) then
                          setenv MACHIN '*I32'
   if ($TARGET == sgi64)  setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*SGI'
endif
#
if (($TARGET == sun32) || ($TARGET == sun64)) then
                          setenv MACHIN '*I32'
   if ($TARGET == sun64)  setenv MACHIN '*I64'
   if ($MODULE == ddi)    setenv MACHIN '*SOC'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*SUN'
endif
#
if ($TARGET == win32) then
                          setenv MACHIN '*I32'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) setenv MACHIN '*W32'
endif
#
if ($TARGET == win64) then
                          setenv MACHIN '*I64'
   if ($MODULE == iolib)  setenv MACHIN '*UNX'
   if ($MODULE == unport) then
     if ($GMS_FORTRAN == ifort) then
       setenv MACHIN '*INT'
     else
       setenv MACHIN '*W64'
     endif
   endif
endif
#
#  Check to see if the configuration step has built actvte.x
#
if (!(-x tools/actvte.x)) then
   echo "Something went wrong with 'config', so that the source code"
   echo "activation program was not correctly compiled.  Please repeat"
   echo "the 'config' step, so that tools/actvte.x is created."
   exit 8
endif
#
#   ----- Activate the source code to produce FORTRAN -----
#   Some big machines will probably refuse to allow you to run a compiled
#   program on a head node.  The three mentioned below do not need the
#   extra support included in the activation program (e.g. DDOT to SDOT
#   conversion, or exponent D to E changing), so 'sed' suffices.
#
echo "Activating $SRCDIR/$MODULE.src to create $MODULE.f for target $TARGET..."
#
setenv   SRCIN $SRCDIR/$MODULE.src
setenv CODEOUT $MODULE.f
switch ($TARGET)
   case ibm64-sp:
   case ibm-bg:
   case cray-xt:
      sed -e "s/^$MACHIN/    /" $SRCIN > $CODEOUT
      breaksw
   default:
      tools/actvte.x
      breaksw
endsw
unsetenv SRCIN
unsetenv CODEOUT
#
#   --------------- special machine "sed hacks" --------------------
#   Not everything can be done with ACTVTE, so we use "sed" (ugh!).
#
#            The "record length" hack.
#    Direct access record length is measured in bytes on most Unix,
#    but some compilers insist in measuring 4-byte words.  This changes
#    only one line in RAOPEN and one line in OPENDA in IOLIB.SRC.
#    SGI's f90 should not execute the following, but SGI's f77 must.
#
if ($MODULE == iolib) then
   set reclhack=false
   if ($TARGET == axp64) set reclhack=true
   if (($TARGET == sgi31) || ($TARGET == sgi64)) then
      if ($GMS_FORTRAN == f77) set reclhack=true
   endif
#
   if ($reclhack == true) then
      mv -f iolib.f iolib.junk
      sed -e "s/     \*      RECL=8\*IRECLN/     *      RECL=2*IRECLN/" \
        iolib.junk > iolib.f
      rm -f iolib.junk
   endif
endif
#
#            The "I'm no longer a 32 bit company" hack.
#   For 64 bit machines which also have a traditional 32 bit product
#   line, the source code typically assumes 32 bits.  This change lets
#   the source code know it is going to be running as a 64 bit machine.
#
if (($MODULE == unport) && \
    (($TARGET == fuji-pp64) || \
     ($TARGET == hpux64)    || \
     ($TARGET == ibm64)     || \
     ($TARGET == ibm64-sp)  || \
     ($TARGET == sgi64)     || \
     ($TARGET == sun64))) then
   mv -f unport.f unport.junk
   sed -e "s/      NWDVAR = 2/      NWDVAR = 1/" unport.junk > unport.f
   rm -f unport.junk
endif
#
#            The "old matrix multiply can be BLAS" hack.
#   If "BLAS3" is set, indicating a math library is found, change a
#   few of the oldest matrix multiply routines to call BLAS routines.
#
if (($MODULE == mthlib) && ($BLAS3 == true)) then
   mv -f mthlib.f mthlib.junk
   sed -e "s/\*BL3/    /" mthlib.junk > mthlib.f
   rm -f mthlib.junk
endif
#
#            The "64 to 32 bit math library" hack.
#   This one is necessary if compiler flags below request the use of
#   64 bit integers in GAMESS -AND- if the vendor's BLAS library
#   insists any integer arguments passed to it be 32 bit quantities.
#   There is a special wrapper file gamess/misc/blaswrap.src that deals
#   with this problem, if we change the source to call the wrappers.
#
if (($TARGET == fuji-pp64) || ($TARGET == ibm64) || ($TARGET == ibm64-sp) || \
    ($TARGET == mac64)     || ($TARGET == sgi64) || ($TARGET == sun64)) then
#
   set par="("
   switch ($MODULE)
#
#          blaswrap.src carefully copies 64 bit ints to 32 bit ints,
#                       and then calls the real BLAS routines, so it
#                       must not be altered here.
      case blaswrap:
      breaksw
#          blas.src has to learn it will be receiving 32 bit integer args,
#                   in case the system math library is for some reason not
#                   installed, and we unfortunately end up using blas.src!
#                   Note that it is OK to also change its local integers
#                   when we change the IMPLICIT, but we must ensure any
#                   integer function present returns 64 bits to GAMESS.
      case blas:
         sed -e "s/INTEGER FUNCTION/INTEGER*8 FUNCTION/g" \
             -e "s/INTEGER(I-N)/INTEGER*4(I-N)/g" \
                blas.f > blas.munged
         mv -f blas.munged blas.f
      breaksw
#           A few files have annoying type and/or EXTERNAL declarations,
#           which lack parentheses, causing woes if we don't omit it.
#           These are then allowed to fall into the default sed change,
#           w/o an open parenthesis to help ensure string uniqueness.
      case dgeev:
      case dgesvd:
      case tdx:
      case tdxitr:
      case tdxni:
      case zheev:
         set par=""
#           Most files will attempt to change a string including an
#           open parenthesis (set above), such as DDOT(... to XDOT(...
#           This is not a perfect strategy, imagine an unrelated
#           routine named MDSCAL, which will be caught up in this!
      default:
         sed -e "s/DASUM$par/XASUM$par/g"   -e "s/dasum$par/XASUM$par/g" \
             -e "s/DAXPY$par/XAXPY$par/g"   -e "s/daxpy$par/XAXPY$par/g" \
             -e "s/DCOPY$par/XCOPY$par/g"   -e "s/dcopy$par/XCOPY$par/g" \
             -e "s/DDOT$par/XDOT$par/g"     -e "s/ddot$par/XDOT$par/g"   \
             -e "s/DNRM2$par/XNRM2$par/g"   -e "s/dnrm2$par/XNRM2$par/g" \
             -e "s/DROT$par/XROT$par/g"     -e "s/drot$par/XROT$par/g"   \
             -e "s/DROTG$par/XROTG$par/g"   -e "s/drotg$par/XROTG$par/g" \
             -e "s/DSCAL$par/XSCAL$par/g"   -e "s/dscal$par/XSCAL$par/g" \
             -e "s/DSWAP$par/XSWAP$par/g"   -e "s/dswap$par/XSWAP$par/g" \
             -e "s/IDAMAX$par/IXAMAX$par/g" -e "s/idamax$par/IXAMAX$par/g" \
             -e "s/DGER$par/XGER$par/g"     -e "s/dger$par/XGER$par/g"   \
             -e "s/DTRMV$par/XTRMV$par/g"   -e "s/dtrmv$par/XTRMV$par/g" \
             -e "s/DGEMV$par/XGEMV$par/g"   -e "s/dgemv$par/XGEMV$par/g" \
             -e "s/DSPMV$par/XSPMV$par/g"   -e "s/dspmv$par/XSPMV$par/g" \
             -e "s/DSPR2$par/XSPR2$par/g"   -e "s/dspr2$par/XSPR2$par/g" \
             -e "s/DGEMM$par/XGEMM$par/g"   -e "s/dgemm$par/XGEMM$par/g" \
             -e "s/DTRMM$par/XTRMM$par/g"   -e "s/dtrmm$par/XTRMM$par/g" \
             -e "s/DTRSM$par/XTRSM$par/g"   -e "s/dtrsm$par/XTRSM$par/g" \
             -e "s/DSYRK$par/XSYRK$par/g"   -e "s/dsyrk$par/XSYRK$par/g" \
             $MODULE.f > $MODULE.munged
          mv -f $MODULE.munged $MODULE.f
      breaksw
   endsw
endif
#
#    IBM Blue Gene compiles w/o underscores on external names,
#    then mixes up one name in our code with a 'wrap_pread' routine.
#
if ($TARGET == ibm-bg) then
   sed -e "s/PREAD(/GMS_PREAD(/g"   -e "s/pread(/GMS_PREAD(/g" \
       $MODULE.f > $MODULE.munged
   mv -f $MODULE.munged $MODULE.f
endif
#
#    systems with very many processors should change default load-balancing
#    from Dynamic-LB (i.e. BLANK ends up meaning DLB) to Static-LB.
#
if (($TARGET == ibm-bg) && ($MODULE == inputa)) then
   sed -e "s/      BALTYP = BLANK/      BALTYP = RSLB/" \
       $MODULE.f > $MODULE.munged
   mv -f $MODULE.munged $MODULE.f
endif
#
#    IBM Blue Gene can't run a command -after- GAMESS execution
#    to rescue the various log files produced by GDDI runs, so
#    we should at least make sure that the master group's log
#    file is kept in 'standard output' by deleting its OPEN.
#
if (($TARGET == ibm-bg) && ($MODULE == gamess)) then
   sed -e "s/         CALL SEQOPN(IW,'OUTPUT','NEW',.FALSE.,'FORMATTED')/C/" \
       $MODULE.f > $MODULE.munged
   mv -f $MODULE.munged $MODULE.f
endif
#
#            The "file-get-environment" hack.
#  This works around inadequate MPI support for environment values.
#  Sometimes MPI implementations will need this, if mpirun does not pass
#  the environment on to the processes it creates.
#  If you want to use it, just hand-edit the state of 'FGEhack' below!
#
#  IBM Blue Gene/L (but not BG/P) needs this due to a very very small
#  total environment space.
#
#  The change consists of changing iolib's getenv call into file_getenv,
#  and activating the subroutine named file_getenv in unport.  If you
#  have decided to select this, recompile only iolib.src and unport.src.
#
if (($TARGET == ibm-bg) && ($GMS_BG_MODEL == P)) goto skip_fge
if  ($TARGET == cray-xt)                         goto skip_fge
#
set FGEhack=false
if (($TARGET == ibm-bg) && ($GMS_BG_MODEL == L)) set FGEhack=true
#
if (($GMS_DDI_COMM == mpi) || ($GMS_DDI_COMM == mixed)) then
   switch ($GMS_MPI_LIB)
     case impi:
     case mvapich2:
     case myrinet:
     case openmpi:
     case mpt:
        set FGEhack=false
        breaksw
     case mpich2:
        set FGEhack=false
        if (($TARGET == win32) || ($TARGET == win64)) set FGEhack=true
        breaksw
     case msmpi:
        set FGEhack=true
        breaksw
     default:
        echo "unknown MPI software requested"
        exit 4
        breaksw
   endsw
endif
#
if ($FGEhack == true) then
   if($MODULE == iolib) then
      sed -e "s/CALL GETENV/CALL FILE_GETENV/g" iolib.f > iolib.munged
      mv -f iolib.munged iolib.f
   endif
   if($MODULE == unport) then
      sed -e "s/\*FGE/    /" unport.f > unport.munged
      mv -f unport.munged unport.f
   endif
endif
#
skip_fge:
#
#          The "NVidia GPU" hack.
#          see ~/gamess/libcchem/aaa.readme.1st for more information
set GPUCODE=false
if ($GPUCODE == true) then
   switch ($MODULE)
      case rhfuhf:
      case mp2:
         echo "Also, selecting '*CXX' lines to use GPUs in $MODULE.src..."
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/\*CXX/    /" \
             $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
         breaksw
      default:
         breaksw
   endsw
endif
#
#   The following hack makes an Apple version print a different banner.
#   The Apple version is source code identical to Linux, but we print
#   something to keep MAC from looking like PC.  Those TV ads demand it!
#
if (($TARGET == mac32) || ($TARGET == mac64)) then
   if ($MODULE == unport) then
      mv -f unport.f unport.junk
      sed -e "s/BIT LINUX VERSION/BIT APPLE VERSION/" \
          unport.junk > unport.f
      rm -f unport.junk
   endif
endif
#
#    HP has a FORTRAN callable delay, we just have to change to HP's name
#
if (($TARGET == hpux32) || ($TARGET == hpux64)) then
   if ($MODULE == unport) then
      mv -f unport.f unport.junk
      sed -e "s/NAPTIME(IDELAY)/SLEEP(IDELAY)/" \
          unport.junk > unport.f
      rm -f unport.junk
   endif
endif
#
#          the Tinker atom count hack
#    this resets dimensions in /atmtyp/ and /atmst/ used to interface
#    between GAMESS and Tinker.  These are shipped for only ten atoms,
#    so as to have no memory overhead when Tinker is not used.  Note
#    that the value to be used (e.g. 12,000 atoms) must match exactly
#    the problem size selected in Tinker's sizes.i include file.
#
if ($TINKER == true) then
   if (($MODULE == inputb) || ($MODULE == fmogrd) || ($MODULE == qmmm)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/MAXATM=10/MAXATM=$NumTinkAtms/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
endif
#
#   ...and this is the end of the ugly "sed hack"s.
#
#   --------- Now we are ready to compile on the target machine ----------
#
cmp:
#
#   Optionally, save pure FORTRAN in temporary directory for
#   syntax scan by the nifty FORTRAN analysis program FTNCHEK.
#
if ($ACTONLY == true) then
   mv -f $MODULE.f ~/scr
   exit
endif
#
#     --- now begins many system specific sections that actually compile ---
#             Begin by erasing any previously generated object code,
#        so that a failure to compile is very obvious when we can't link.
#
if (-e $OBJDIR/$MODULE.o) rm -f $OBJDIR/$MODULE.o
#
#  the 64 bit alpha chip, more formally called AXP.
#  These were marketed by Digital, Compaq, and HP as well as some 'whitebox'
#  companies.  The vendor's operating system was called OSF/1 or Tru64,
#  but these systems may also run Linux.  This section is therefore
#  based on using the vendors' compiler for AXP, for either the vendors'
#  operating system, or for Linux.
#  If you are using Linux on AXP, and have only GNU compilers, please
#  use 'linux64' instead.
#
#  Options for the native AXP FORTRAN 5.2 compiler under Tru64 V4.0F are
#     -O0 turns off all optimization
#     -O1 does local optimizations
#     -O2 also does global optimizations
#     -O3 also does additional global optimizations
#     -O4 also does routine inlining (default)
#     -O5 also does software pipelining
#     -fast implies less accurate but faster libraries, etc. and -O4.
#     -c means compile only
#     -i8 selects use of 64 bit integers
#     -v gives compiler phase information, and timings
#     -automatic and -static use/avoid stack for local variables
#     -col72 chops source lines past 72 columns
#     -stand nosemantic means don't warn of nonANSI usage (default)
#     -stand nosource_form means don't warn of tabs/lowercase (default)
#     -stand nosyntax means don't warn of nonANSI syntax (default)
#
#  Note that we've tried f77 3.3, 3.7, 3.8, and 5.2, but nothing in between.
#  This is an excellent compiler, and probably all versions work.
#  Under AXP Linux, it has a different name, but is the same great compiler.
#
if ($TARGET == axp64) then
                         set FORT='f77'
   if (`uname` == Linux) set FORT='fort'
   set OPT = '-O4'
   if ($MODULE == zheev) set OPT='-O0'
   set echo
   $FORT -c -i8 -v -automatic -col72 $OPT $MODULE.f
   unset echo
endif
#
#    Cray parallel vector processor (e.g. T90, J90, SV1...)
#    Cray T90 tested in February of 2000
#    Cray SV1 rev C with CF90 3.4.0.0.4 tested in March of 2000
#    Note that all Cray clauses now use f90 compiler only.
#
if ($TARGET == cray-pvp) then
   set OPT = '-O2 '
   if ($MODULE == int2a)  set OPT='-Ovector0,scalar3 '
   if ($MODULE == grd2a)  set OPT='-Ovector0,scalar2 '  # Jerry says
   if ($MODULE == grd2b)  set OPT='-Ovector0,scalar3 '
   if ($MODULE == grd2c)  set OPT='-Ovector0,scalar3 '
   if ($MODULE == gugem)  set OPT='-Ovector0,scalar3 '
   if ($MODULE == vector) set OPT='-O1 '
   if ($MODULE == gvb)    set OPT='-O1 '   # use -O0 if exam15,16,21 fail
   if ($MODULE == gamess) set OPT='-O0 '
   if ($MODULE == efinp)  set OPT='-O0 '
   if ($MODULE == efinta) set OPT='-Ovector0,scalar3 '
   if ($MODULE == efintb) set OPT='-Ovector0,scalar3 '
   if ($MODULE == efgrda) set OPT='-Ovector0,scalar3 '
   if ($MODULE == efgrdb) set OPT='-Ovector0,scalar3 '
   if ($MODULE == efgrdc) set OPT='-Ovector0,scalar3 '
   if ($MODULE == efgrd2) set OPT='-Ovector0,scalar3 '
   if ($MODULE == ormas1) set OPT='-O0 '   # also from Jerry
   if ($MODULE == zheev)  set OPT='-O0'    # defensive compiling
   set echo
   f90 -c -V $OPT $MODULE.f
   unset echo
endif
#
#  Compiler flags for Cray T3E under UNICOS/mk 2.0.3.18, cf90 3.1.0.3
#  -Oscalarn is various scalar optimizations (n=0,1,2,3)
#  -Oaggress increases table sizes used during optimizations
#  -O[no]msgs,[no]negmsgs [disables]enables compiler optimization messages
#  -dp disables double precision
#
if ($TARGET == cray-t3e) then
   set OPT = '-Oscalar3,aggress'
   if ($MODULE == grd2c) set OPT='-O1'   # for cf90 3.1.0.3 and others
   if ($MODULE == hss1b) set OPT='-O1'   # for cf90 3.4.0.0
   if ($MODULE == zheev) set OPT='-O0'   # defensive compiling
   set echo
   env TARGET=cray-t3e f90 -c $OPT -dp -Onomsgs,nonegmsgs $MODULE.f
   unset echo
endif
#
#  Compiler flags for Cray X1 under UNICOS/mp 2.5+, ftn 5.3+
#  -O[no]msgs,[no]negmsgs [disables]enables compiler optimization messages.
#  -Oscalarn is various scalar optimizations (n=0,1,2,3)
#  -Ovectorn is various vector optimizations (n=0,1,2,3)
#  -Oaggress causes the compiler to treat each subroutine as a single
#       optimization region.
#  -Ossp will build GAMESS in SSP (single-streaming processor) mode.
#        remove -Ossp to use multi-streaming processor mode (discouraged)
#  -dp disables double precision.
#  -rm generates listing files.
#  -xomp disables all OpenMP statements.
#  -sdefault64 uses default 64-bit integers and reals (among others).
#
if ($TARGET == cray-x1) then
   set OPT = '-O2'
   set LST = ' '         # change to '-rm -Omsgs,negmsgs' for listing file
   if ($MODULE == int2a)  set OPT='-O1'
   if ($MODULE == vector) set OPT='-Oscalar3,vector3'
   if ($MODULE == zheev)  set OPT='-O0'   # defensive compiling
   set echo
   ftn -c -V $OPT $LST -Ossp,aggress -xomp -dp -sdefault64 $MODULE.f
   unset echo
endif
#
#  Compiler flags for Cray XD1 using PGI F90 6.0 or higher
#
#  -fastsse is a smorgasboard of
#      -fast -Mvect=sse -Mscalarsse -Mcache_align -Mflushz
#  and -fast is a further feast, namely
#      -O2 -Munroll=c:1 -Mnoframe -Mlre
#  typing "pgf77 -fastsse -help" can be a bit more expansive on the -M's.
#
#  For the XD1, make sure your "mpif90" script points to pgf90 and not a
#    different compiler.
#  'setenv PGI' should not be needed as this should be done automatically
#    by modules.  If you do not have $PGI environment variable set,
#    uncomment these 2 lines (first change /usr/pgi to wherever the
#    PGI compiler is installed):
#    setenv PGI /usr/pgi
#    setenv PATH $PATH\:$PGI/linux86-64/bin
#
if ($TARGET == cray-xd1) then
   if ($TARGET == cray-xd1) set USE_FTN = 'mpif90'

#     choose 'amd64e' in next line if your Opteron supports SSE3 instructions
   set AMD_TRGT = amd64

   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif

#      these are probably very aggressive optimizations.
#      The settings for mcpgrd below are gentler, and therefore safer.
   set OPT = '-fastsse -Munroll -Mipa=fast,safe'
   if ($MODULE == dftgrd) set OPT='-fastsse -Munroll -Mipa=fast,safe -Minline'
   if ($MODULE == int2a)  set OPT='-fastsse -Munroll -Mipa=fast,safe -Minline'
   if ($MODULE == int2b)  set OPT='-fast -Mnounroll'
   if ($MODULE == mcpgrd) set OPT='-O2 -Mscalarsse -Munroll -Mcache_align -Mflushz'
   if ($MODULE == prppop) set OPT='-fastsse -Munroll -Mipa=fast,safe -Minline'

   if (($MODULE == mpcdat) || ($MODULE == mpcgrd) || ($MODULE == mpcint) || \
       ($MODULE == mpcmol) || ($MODULE == mpcmsc)) set OPT = '-O0'

   set echo
   $USE_FTN -c $OPT -Mnosecond_underscore -tp $AMD_TRGT -i8 $MODULE.f
   unset echo
endif
#
#   Cray XT Series
#
if ($TARGET == cray-xt) then
#
#     echo out the loaded modules, but only once at the top of 'compall'
   if ($MODULE == aldeci) then
      echo "--------------------------------"
      echo "Cray XT system software setup is"
      echo "--------------------------------"
      module list
   endif
#
#     next seems to be always 'ftn', which is how 'config' sets this.
   set FC = $GMS_FORTRAN
#
#         two choices not included in the configuration step
#         These must match 'compddi' and 'lked', and loaded software modules.
#            valid choices: pathscale, intel, cray, pgi
   set GMS_XT_COMP = 'pgi'
#            valid choices: i7, barcelona, shanghai, or blank
   set GMS_XT_ARCH = ' '

   switch ($GMS_XT_COMP)
   case pgi:
      echo "** Compiler: PGI"
      set OPT = '-fastsse -O2 -Munroll'
   #       increase the optimization level on the following:
      if ($MODULE == int2a)  set OPT = '$OPT -Minline'
      if ($MODULE == prppop) set OPT = '$OPT -Minline'
      if ($MODULE == dftgrd) set OPT = '$OPT -Minline'
      if ($MODULE == mp2ddi) set OPT = '-fastsse -O3 -Munroll'
      if ($MODULE == dftgrd) set OPT = '-fastsse -O3 -Munroll'
   #       back off the optimization level on the following:
      if ($MODULE == basccn) set OPT = '-O2'
      if ($MODULE == cphf)   set OPT = '-O2'
      if ($MODULE == int2b)  set OPT = '-O2 -Mnounroll'
      if ($MODULE =~ mpc*)   set OPT = '-O0'
      if ($MODULE == symslc) set OPT = '-O2'
      set BASE   = '-i8 -mcmodel=medium'
      set INFO   = '-Minfo=all -Mneginfo=loop' # if analyzing performance
      set INFO   = ' '
      switch ($GMS_XT_ARCH)
      case barcelona:
         echo "Using Quadcore Barcelona flags"
         set XT_OPT = '-tp barcelona-64 -Mfpmisalign'
         breaksw
      case shanghai:
         echo "Using Quadcore Shanghai flags"
         set XT_OPT = '-tp shanghai-64 -Mfpmisalign'
         breaksw
      case i7:
         set XT_OPT = '-tp x64'
         breaksw
      default:
         echo "Using default K8 flags"
         set XT_OPT = ' '
         breaksw
      endsw
      breaksw
   case pathscale:
      echo "** Compiler: Pathscale"
      set OPT    = "-Ofast"
      set OPT    = "-O3 -OPT:Ofast -ffast-math -fno-math-errno"
      set OPT    = "-O2"
      if($MODULE == mp2ddi) set OPT = "-Ofast"
      if($MODULE == zheev)  set OPT = "-O0"
      set BASE   = "-m64 -i8 -r8"
      set INFO   = " "
      set XT_OPT = "-march=barcelona -mcpu=barcelona -mtune=barcelona -msse4a "
      breaksw
   case cray:
      echo "** Compiler: Cray"
      set OPT    = " "
      set BASE   = "-target=linux -sdefault64"
      set INFO   = "-rm"
      set XT_OPT = " "
      breaksw
   case intel:
      echo "** Compiler: Intel"
      set FC = ifort
      set OPT = "-O2"
      if ($MODULE == mp2ddi) set OPT='-O3'
      if ($MODULE == dftgrd) set OPT='-O0'
      if ($MODULE == guess)  set OPT='-O0' # 10.0, exam39
      if ($MODULE == morokm) set OPT='-O0' # Jan Fredin
      if ($MODULE == prpel)  set OPT='-O1' # 10.0, exam13
      if ($MODULE == tdxitr) set OPT='-O1' # 10.0, exam39
      if ($MODULE == zheev)  set OPT='-O0' # defensive compiling
      if ($MODULE == prppop) set OPT='-O0' # defensive compiling
      set BASE   = "-i8 -auto -ftz -assume byterecl"
      set INFO   = "-opt-report -vec-report3"
      set INFO   = " "
      set XT_OPT = "-xSSE4.2"
      breaksw
   default:
      echo "invalid Cray XT compiler"
      exit
      breaksw
   endsw

   if ($GMS_XT_COMP != ifort) then
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
   endif
#
#              now, actually compile the module for the XT.
#
   if(-e $MODULE.f) then
     echo "Compiling fixed format FORTRAN file $MODULE.f"
     set echo
        $FC -c $BASE $OPT $XT_OPT $INFO $MODULE.f
     unset echo
   else if(-e $MODULE.f90) then
     echo "Compiling free format FORTRAN file $MODULE.f90"
     set echo
        $FC -c $BASE $OPT $XT_OPT $INFO $MODULE.f90
     unset echo
   else
     echo "ERROR: FORTRAN Source for module $MODULE was not found"
     exit 4
   endif
endif
#
#   Fujitsu PrimePower
#   Split into 32bit and 64bit versions, since the 32bit executable is
#   slightly (5%) faster but cannot use larger than 2Gbyte memory.
#   From Roger Amos at ANU Supercomputer Facility, 1/2005
#
#   Compilation options: do not use -O5 or FMADD as code is slower.
#   More complicated cache optimisation does not improve performance.
#
#   64bit version tested with largepage=1, and largepage=2, the
#   program executes correctly but there is no performance advantage.
#
#   tested with Solaris8 and Solaris9 and compiler
#   Fujitsu Fortran 5.5 (Feb 19 2004 17:23:48)
#   note: the compiler has two names, f90 and frt, which are the same.
#
if ($TARGET == fuji-pp32) then
   set OPT = '-Kfast_GP2=3,prefetch=5'
   set echo
   f90 -c -fs $OPT $MODULE.f
   unset echo
endif

#   -KV9 allows large memory space
#   -CcdII8 causes all generic integer variables to be 64 bit
#
if ($TARGET == fuji-pp64) then
   set OPT = '-Kfast_GP2=3,prefetch=5,largepage=2'
   if ($MODULE == gamess) set OPT='-O0'  # only fails in 64 bit mode
   set echo
   f90 -c -fs $OPT -KV9 -CcdII8  $MODULE.f
   unset echo
endif
#
#  HP-UX systems,
#         the latest tested version numbers are
#  HP-UX B.11.0,  using f90 2.4.10  on PA-RISC  32 bit
#  HP-UX B.11.23, using f90 2.8     on Itanium2 64 bit
#       (f90 +version reports version number)
#
#  The f90 options apply to both 32 and 64 bit compilations, and mean:
#    +On   selects optimization level; n=0,1,2,3,4  (-O means +O2)
#          0 is none
#          1 is block transforms
#          2 is full within subprograms
#          3 crosses subprograms (includes inlining) also loop transforms
#          4 is link time iptimizations, applies only to Itanium processors.
#
#    +Oaggressive selects the following four additions to +O2:
#    +Oentrysched  = instruction scheduling on entry/exit
#    +Olibcalls    = special trig and power functions (lacking error hand.)
#    +Onofltacc    = permits use of a faster single multiply/add instruction.
#    +Onoinitcheck = disable initialization of any unitialized datum
#         other optimizations include
#    +Onolimit     = ignores time and memory limits when optimizing
#    +Ofastaccess  = gives fast access to global data
#
#    +Oaggressive is a decremented optimization, to be replaced in newer
#    systems by +Ofast.  +Ofast selects the combination +O2, +Olibcalls,
#    +Onolimit, +Ofltacc=relaxed, +FPD, +DSnative (on IPF), +Oshortdata
#    and requires f90 2.5 or higher.
#
#    +[no]save governs automatic variable allocation strategy
#    +[no]ppu governs postpend underscores on names of external refs.
#    +U77 gives access to BSD's 3F library
#    +DD64 uses the LP64 data model.
#    +i8 treats all integer or logical data as 64 bits
#
if ($TARGET == hpux32) then
   set OPT='+O2 +Oaggressive +Onolimit +Ofastaccess'
   if ($MODULE == unport) set OPT="$OPT +U77"
   if ($MODULE == zheev)  set OPT='+O0'   # defensive compiling
   set echo
   f90 -c $OPT +nosave +noppu $MODULE.f
   unset echo
endif
#
if ($TARGET == hpux64) then
#
#    the 64 bit libraries have a name conflict with our ICOPY
#
   if ($MODULE == guess) then
      mv -f guess.f guess.junk
      sed -e "s/SUBROUTINE ICOPY/SUBROUTINE IYPOC/" \
          guess.junk > guess.f
      rm -f guess.junk
   endif
#      +O3 failed to run 9 of 37 example jobs correctly, so +O2 is safer.
   set OPT='+O2'
   if ($MODULE == unport) set OPT="$OPT +U77"
   if ($MODULE == trfdm2) set OPT="+O1"   # for CI gradients, exam05
   if ($MODULE == zheev)  set OPT='+O0'   # defensive compiling
   set echo
   f90 -c $OPT +DD64 +i8 +nosave +noppu $MODULE.f
   unset echo
endif
#
#   For IBM 32 or 64 bit RS/6000 workstations or SP parallel systems,
#   the options for XL FORTRAN 7.1.0 and AIX 4.3.3 are
#       -c means compile only
#       -O2 and -O3 choose optimization levels (there is no -O1)
#       -qarch=com,601,pwr,pwr2,pwr3 (see also -qtune)
#       -qflag requests I,L,W,E,S,Q (information, language,
#              warning, error, severe, quiet) messages
#       -qflttrap=ov:zero:inv:inex:enable traps bad arithmetic
#       -qhalt stops compiler after certain error level
#       -qnosave forces non-static storage
#       -qinitauto=ff initializes non-static storage (useful if debugging)
#       -qextchk checks calling args and common lengths at link
#       -qsource requests a printable .lst file.
#       -qtune selects target chip
#
#   The following clause requires XL FORTRAN 3.2 or higher.
#   Use of 64 bit integers requires XL FORTRAN 6.1 or higher.
#   The command to find your FORTRAN version level depends on your
#   AIX version: v3 is "lslpp -h xlfcmp.obj", v4/v5="lslpp -h xlfcmp".
#
#   To look for XLF optimization problems in one routine, place
#          @PROCESS OPT(0) SAVE
#   above the suspect routine.  Note that the directive remains in
#   force for only one subprogram, and must be above its first line.
#
#   To profile code during development stages,
#     1. "comp" desired modules with -pg added to the xlf flags
#     2. "lked" after adding -p to the xlf flags.
#     3. execute to completion, generating 'mon.out' file.
#     4. generate results by 'prof gamess.00.x mon.out'.
#
#   A possible way to look for memory allocation problems is VALGRIND.
#   Compile with the -p flag, and then be sure to look at child's
#   memory use: "valgrind --trace-children=yes rungms".  This program
#   is available for Linux (not AIX) at valgrind.org.  Untried by MWS.
#
if (($TARGET == ibm32) || ($TARGET == ibm64) || ($TARGET == ibm64-sp)) then
   set FORT='xlf'
   if ($TARGET == ibm64-sp) set FORT='mpxlf_r'
#         old 32 bit workstations, whether Power, Power2, or PowerPC
#         should all select plain vanilla common architecture.  It is
#         faster, and runs on any combination of these chips you own.
#         under xlf 4.1.0 a few files won't fully optimize
   if ($TARGET == ibm32) then
      set BITS=''
      set OPT='-O3'
      if ($MODULE == gugdm)  set OPT='-O2'
      if ($MODULE == gugem)  set OPT='-O2'
      if ($MODULE == qrel)   set OPT='-O2'
      if ($MODULE == trnstn) set OPT='-O2'
      set ARCH='com'
      set TUNE='604'   # PowerPC tuning makes even Power1 run faster
   endif
#         64 bit workstations (or SP) is sure to be Power3 or higher chip.
#         ISU's AIX systems are a mix of Power3 and Power4, while our
#         Linux systems are all Power5 (else clause).  Please change
#         the arch/tuning to better match your system, as you like.
#
#         xlf 5.1.1 and 6.1.0 and 7.1.0 and 8.1.0 and 9.1.0 are mostly OK,
#         but 10.1.0 has a few more problems than usual.  Ever notice that
#         IBM never puts out anything but x.1.x?
   if (($TARGET == ibm64) || ($TARGET == ibm64-sp)) then
      set BITS='-q64 -qintsize=8'
      set OPT='-O3'
      if (`uname` == AIX) then
         set ARCH='pwr3'
         set TUNE='pwr3'
      else
         set ARCH='pwr5'
         set TUNE='pwr5'
         if ($MODULE == mcpgrd) set ARCH='pwr3'  # or: -O2/pwr5 in xlf 9.1
         if ($MODULE == mcpgrd) set TUNE='pwr3'
      endif
      if ($MODULE == fmoint) set OPT="-O3 -qstrict"
      if ($MODULE == gugdga) set OPT="-O2"  # 10.1 (OK on older xlf)
      if ($MODULE == gugdgb) set OPT="-O2"  # 10.1 (OK on older xlf)
      if ($MODULE == mpcmol) set OPT="-O2"  # 10.1 (OK on older xlf)
      if ($MODULE == pcmcv2) set OPT="-O2"  # exam31, as of 2011 changes
   endif
#
   set echo
   $FORT -c $OPT $BITS -qarch=$ARCH -qtune=$TUNE \
         -qflag=W:W -qhalt=W -qspillsize=2500 -qnosave $MODULE.f
   unset echo
endif
#
#   IBM Blue Gene is a 32 bit processor
#   The original "L" is based on the PPC440 embedded CPU with a dual FPU.
#   The new "P" model is a newer PowerPC chip.
#
if ($TARGET == ibm-bg) then
   if ($GMS_BG_MODEL == L) then
      set FORT="blrts_xlf"
      set ARCH='440'
      set TUNE='440'
   endif
   if ($GMS_BG_MODEL == P) then
      set FORT="bgxlf_r"
      set ARCH='450d'
      set TUNE='450'
   endif
   set OPT='-O3'
   if ($MODULE == grd2b)  set OPT='-O3 -qspillsize=1500'
   if ($MODULE == gugdm)  set OPT='-O2'
   if ($MODULE == gugem)  set OPT='-O2'
   if ($MODULE == qrel)   set OPT='-O2'
   if ($MODULE == trnstn) set OPT='-O2'
   if ($MODULE == ormas1) set OPT='-O2'
   if ($MODULE == prpel)  set OPT='-O0'  # Graham, 2010, for the P
   if ($MODULE == zheev)  set OPT='-O0'
   if ($MODULE == qeigen) set OPT="-O3 -qstrict"
   if ($MODULE == fmoint) set OPT="-O3 -qstrict"
#        higher optimization for selected modules
   if ($MODULE == scflib) set OPT="-O3 -qhot"
   if ($MODULE == int2a)  set OPT="-O3 -qhot"
   if ($MODULE == int2b)  set OPT="-O3 -qhot"
   if ($MODULE == int2r)  set OPT="-O3 -qhot"
   if ($MODULE == grd2a)  set OPT="-O3 -qhot"
   if ($MODULE == grd2b)  set OPT="-O3 -qhot"
   if ($MODULE == grd2c)  set OPT="-O3 -qhot"
   if ($MODULE == mp2ddi) set OPT="-O3 -qhot"
   if ($MODULE == rhfuhf) set OPT="-O3 -qhot"
   set echo
   $FORT -c $OPT -qarch=$ARCH -qtune=$TUNE \
         -qflag=W:W -qhalt=W -qmaxmem=-1  -qnosave $MODULE.f
   unset echo
endif
#
#   ------ Linux on 32 bit chips ------
#   please see the 64-bit Linux section for information on compiler sources.
#
if ($TARGET == linux32) then
#
#  there are four supported 32 bit compilers: g77, gfortran, ifort, pgf77
#          g77,
#             the gnu FORTRAN being included in older Linux distributions
#             lacks support for unit numbers over 99, or REAL*16
#          gfortran,
#             the gnu FORTRAN being included in newer Linux distributions
#             this allows unit numbers over 99, but not REAL*16
#          Intel's commercial ifort,
#             supports unit numbers above 99 and REAL*16 (runs all of GAMESS)
#          Portland's commercial pgf77,
#             lacks support for REAL*16
#
    switch ($GMS_FORTRAN)
#
#   The meaning of g77's flags are
#      -O0, -O1, -O2, -O3 are the optimization levels, -O means -O1
#      -Wno-globals -fno-globals together suppress argument type checking.
#      -fautomatic defeats use of static storage
#      -malign-double uses 64 bit data alignment
#   g77 does not support FORTRAN logical units above 99, or 128 bit math.
#
   case g77:
   set OPT = '-O2'
   if ($MODULE == ormas1) set OPT='-O2 -fno-move-all-movables' # RH9, g77 3.3
   if ($MODULE == zheev)  set OPT='-O0'  # defensive compiling
   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   if (($MODULE == iolib) || ($MODULE == inputa) || \
       ($MODULE == gamess) || ($MODULE == mp2ims)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/MXUNIT=299/MXUNIT=99/g" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   set echo
   g77 -c $OPT -malign-double -fautomatic \
           -Wno-globals -fno-globals $MODULE.f
   unset echo
   breaksw
#
#   gfortran was included with Fedora Core distributions starting around FC4.
#   This is a 32 bit version, i.e. not using -fdefault-integer-8!
#   Unlike g77, gfortran allows for unit numbers above 100.
#   Like g77, gfortran does not support quadruple precision.
#      -Ox optimization level is from the gcc back end, x can be 0,1,2,3
#      -std=legacy  suppresses warnings about use of f77 constructs.
#
   case gfortran:
   set OPT='-O2'
   if ($MODULE == zheev)  set OPT='-O0'  # defensive compiling
   if ($MODULE == pcmcv2) set OPT='-O1'  # EFP+CPCM, ala Francois, v4.1.2
   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   set echo
   gfortran -c $OPT -std=legacy $MODULE.f
   unset echo
   breaksw
#
#    3. Intel Fortran Compiler for Linux
#
#    Note that this is more agressive (-O3 compared to -O2) than the
#    64 bit compile below.  If an ifort version gives you problems,
#    drop the optimization back to -O2.
#    Dmitri likes to use "-O3 -xN -ssp -unroll8 -ip -pad -opt_report",
#    but that may cause certain ifort versions to fail on some files.
#    See http://staff.aist.go.jp/d.g.fedorov/compgms.html for aggressive
#    optimizations in 32 bit mode, as a function of the ifort version.
#
   case ifort:
   set OPT = '-O3'
   if ($MODULE == delocl) set OPT='-O0'  # from Cheol
   if ($MODULE == prpamm) set OPT='-O0'  # for exam13
   if ($MODULE == zheev)  set OPT='-O0'
   set EXTRAOPT=" "
   if ($GMS_IFORT_VERNO >=  8) set EXTRAOPT="$EXTRAOPT -assume byterecl"
   if ($GMS_IFORT_VERNO >= 10) set EXTRAOPT="$EXTRAOPT -vec-report0"
   if ($GMS_IFORT_VERNO  < 12) set EXTRAOPT="$EXTRAOPT"
   if ($GMS_IFORT_VERNO >= 12) set EXTRAOPT="$EXTRAOPT -warn nousage"
   set echo
   ifort -c -i4 $OPT -ftz -auto $EXTRAOPT $MODULE.f
   unset echo
   breaksw
#
#    4. Portland Group compiler.
#    This is a synthesis of recommendations from Fred Arnold and Brian
#    Salter-Duke.  -fast means -O2 -Munroll -Mnoframe, the latter option
#    seems to be the source of several incorrect results.  It is said that
#    "-Munroll" and "-tp p6" gives no significant improvement in run times.
#    The -Mlfs flag is supposed to cure the 2 GB file size limit.
#    exam19 may hang when using this compiler.  -Mlfs at link-time
#    enables large file support.
#
   case pgf77:
   if (($MODULE == qfmm) || ($MODULE =~ so*) || ($MODULE == zheev)) then
       mv -f $MODULE.f $MODULE.junk
       sed -e s/DREAL/DBLE/g $MODULE.junk > $MODULE.f
       rm -f $MODULE.junk
   endif
   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   set OPT = '-O2'
   if ($MODULE == zheev)  set OPT = '-O2 -Kieee'
   if ($MODULE == bassto) set OPT = '-O0'  # Takako
   set echo
   pgf77 -c $OPT -Msecond_underscore $MODULE.f
   unset echo
   breaksw
#
   default:
      echo "Please spell your Linux 32 bit FORTRAN compiler name correctly."
      exit 4
      breaksw
   endsw
#                     ... end of Linux on 32 bit processors.
endif
#
#   ------ Linux on 64 bit chips ------
#   This should work on any 64 bit Linux release, for any type of
#   chip, ranging from AXP to SPARC to PowerPC to AMD to Intel,
#   if you are using 'gfortran'.  The commercial compilers tend to
#   be more chip-specific.
#
#   Typical software requirement:
#     Fedora (or other Linux distribution) in a 64 bit version,
#     the 64 bit gcc 4.x included for free in this Linux distribution,
#     one of the possible FORTRAN compilers: gfortran, ifort, pgf77, pathf90
#     and an appropriate math library containing the BLAS.
#
#  sources for FORTRAN
#  ===================
#
#  Gnu's gfortran:
#     This is included in recent Linux distributions, free compiler.
#     gfortran is a mature software product, and any version higher
#     than 4.1 should work properly.  In our tests, it is very similar
#     in speed to Intel's compiler, with fewer optimization problems,
#     so it is our normal first choice.
#
#  Intel's ifort:
#     Intel's compilers are commercially licensed software, but Intel allows
#     downloads of a "non-commercial unsupported version" at no charge:
#         http://developer.intel.com/software/products/compilers
#     Any 64 bit chip which answers "uname -p" by x86_64 (Opteron or EM64T)
#     or by ia64 (Itanium2) can use ifort
#
#  Portland Group's pgf77:   (note that you don't need pgcc)
#     You need a "pgf77 workstation" license, which was priced at $449
#     for academic use in the US as of June 2006: www.pgroup.com
#     You can install a math library called ACML (AMD core math library),
#     most easily while installing pgf77, or as a free download from AMD.
#     Be sure to set up the use of this compiler, in .cshrc for example,
#         setenv PATH $PATH\:/usr/pgi/linux86-64/bin
#         setenv PGI /usr/pgi
#
#  Pathscale's pathf90: use Google to find out about this compiler
#
#  sources for math library
#  ========================
#     MKL is a very fast library for 32 or 64 bit Intel chips,
#         and can be called from gfortran as well as ifort.
#         Look at the same developer's web site as for ifort.
#
#     Atlas is packaged as a RPM for Linux, e.g. rpmfind.net will help
#         you find atlas-3.6.0-11.fc6.x86_64.rpm  (or other processor)
#         Take .i386.   for 'uname -p'=i386 or i686   meaning    32 bit chips
#         Take .ia64.   for 'uname -p'=ia64   means Itanium2     64 bit chips
#         Take .x86_64. for 'uname -p'=x86_64 means Intel or AMD 64 bit chips
#
#     ACML is a free download from AMD, from
#         http:/developer.amd.com -> developer tools -> libraries ->
#               ACML for Linux built with GFORTRAN (INT*8)
#
if ($TARGET == linux64) then
#
#  there are four supported 64 bit compilers: gfortran, ifort, pgf77, pathf90
#
   switch ($GMS_FORTRAN)

   case gfortran:
#           -finit-real=<zero|inf|-inf|nan>  could be interesting debug opt
#           -fno-automatic forces static storage of all local variables
      set OPT='-O2'
      if (".$GMS_DEBUG_FLAGS" != .) set OPT="$GMS_DEBUG_FLAGS"
      if ($MODULE == zheev)  set OPT='-O0'  # defensive compiling
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      set echo
      gfortran -c -fdefault-integer-8 $OPT -std=legacy $MODULE.f
      unset echo
      breaksw

   case ifort:
#     -i4/-i8 set default integer length
#     -On can have n=1,2,3.  Use of 3 caused problems with earlier
#          compilers, so it isn't being used here.  Try it if you like.
#     stack storage for locals is governed by -auto versus -save.
#     -assume byterecl was introduced at ifort 8.0 (older versions will
#        print a message saying this flag is ignored).  Newer versions
#        need this so that direct access file opens are measured in
#        bytes rather than the new default in v8.0, namely 4-byte units.
#     -vec-report0 suppresses loop vectorization messages (new in 10.0)
#     -w95 suppresses Hollerith initialization and other f90-like warnings
#     -cm  means suppress comments about programming practices,
#          these two options spelled '-warn nousage' at version 12.
#     -WB means warn but don't fail on out-of-bounds array references
#     -ftz flushes underflow results to zero
#
      set OPT = '-O2'
      if (".$GMS_DEBUG_FLAGS" != .) set OPT="$GMS_DEBUG_FLAGS"
#       alas, I'm so tired of hearing about so many versions failing to
#       diagonalize, that this time critical code is run w/o optimization.
#       Very many (all?) ifort versions have problems with eigen.src.
      if ($MODULE == eigen)  set OPT='-O0' # read note just above.
      if ($MODULE == fmo)    set OPT='-O1' # 12.0.4, exam37
      if ($MODULE == guess)  set OPT='-O0' # 10.0, exam39
      if ($MODULE == locpol) set OPT='-O1' # 10.0, makefp/gmres
      if ($MODULE == morokm) set OPT='-O0' # Jan Fredin
      if ($MODULE == prpel)  set OPT='-O1' # 10.0, exam13
      if (($MODULE == rohfcc) && ($GMS_IFORT_VERNO == 12)) \
                             set OPT='-O1' # 12.0.1, exam42 (op.shell CC)
      if ($MODULE == tdxitr) set OPT='-O1' # 10.0, exam39
      if ($MODULE == vscf)   set OPT='-O0' # intensities for combinations
      if ($MODULE == zheev)  set OPT='-O0' # defensive compiling

      set EXTRAOPT=" "
      if ($GMS_IFORT_VERNO >=  8) set EXTRAOPT="$EXTRAOPT -assume byterecl"
      if ($GMS_IFORT_VERNO >= 10) set EXTRAOPT="$EXTRAOPT -vec-report0"
      if ($GMS_IFORT_VERNO  < 12) set EXTRAOPT="$EXTRAOPT"
      if ($GMS_IFORT_VERNO >= 12) set EXTRAOPT="$EXTRAOPT -warn nousage"
      set echo
      ifort -c -i8 $OPT -ftz -auto $EXTRAOPT $MODULE.f
      unset echo
      breaksw

   case pgf77:
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      set OPT = '-fastsse -Mipa=fast,safe -Mprof=func'
      if ($MODULE == int2b)  set OPT = "$OPT -Mnounroll"
      if ($MODULE == mcpgrd) set OPT = '-O1'
      if ($MODULE == mpcdat) set OPT = '-Mprof=func -O0'
      if ($MODULE == mpcgrd) set OPT = '-Mprof=func -O0'
      if ($MODULE == mpcint) set OPT = '-Mprof=func -O0'
      if ($MODULE == mpcmol) set OPT = '-Mprof=func -O0'
      if ($MODULE == mpcmsc) set OPT = '-Mprof=func -O0'
      if ($MODULE == zheev)  set OPT = '-Mprof=func -O0' # defensive compiling
      set echo
      pgf77 -c -i8 -i8storage -mcmodel=medium $OPT $MODULE.f
      unset echo
      breaksw
#
#        Please use Google to learn more about this compiler, e.g.
#           source of compiler, price, math library, et cetera.
#
   case pathf90:
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      set OPT = '-O2'
      if ($MODULE == zheev)  set OPT='-O0'
      set echo
      pathf90 -c -r8 -i8 $OPT $MODULE.f
      unset echo
      breaksw
#
   default:
      echo "Please spell your Linux 64 bit FORTRAN compiler name correctly."
      exit 4
      breaksw
   endsw
#                     ... end of Linux on 64 bit processors.
endif
#
#   Apple Macintosh system using OS X
#    jargon: 10.0=cheetah, 10.1=puma,     10.2=jaguar,   10.3=panther,
#            10.4=tiger,   10.5=leopard,  10.6=snow leopard
#
#   for OS X up to and including 10.4, you should use 'mac32'
#   for OS X 10.5 and above,           you should use 'mac64'
#
#   Either target will work for PowerPC or Intel processors, but if you
#   have both types, you must compile twice, once for each chip.
#
#   Software setup is painless:
#
#   Step 1 is to install the "Xcode" software to get a C compiler, gcc.
#   The Xcode development environment is available for download at
#          http://developer.apple.com
#   but Xcode can also be found on the installation media, as of Tiger.
#   The Xcode must match your OS X version, and also must be new enough
#   to match the requirement shown on the web page in the next step.
#   The only way to learn the Xcode version is reading its PDF file.
#
#   Step 2 is to download the FORTRAN compiler from
#          http://hpc.sourceforge.net
#   Thanks to Gourav Khanna for making FORTRAN so easy!
#   Take note of the Xcode release he used, and download the appropriate
#   chip specific 'gfortran' if you have Leopard.  Download g77 only if
#   you have an older operating system, and therefore must use 'mac32'.
#   Don't download a C compiler, as the gcc compiler is provided by Xcode!
#
#   Step 3 is to install gfortran (or g77), requiring admin priveledges:
#       sudo tar -xvf gfortran-leopard-intel-bin.tar -C /
#   which installs under /usr/local.  Add /usr/local/bin to your path.
#
#   If you prefer to install a .dmg file instead of unpacking a tar
#   file, you might try the gfortran build from the "R project".  A
#   link that, and other FORTRAN resources, is
#          http://www.webmo.net/support/fortran_osx.html
#
if ($TARGET == mac32) then
#  there are two supported 32 bit compilers: g77, gfortran
   switch ($GMS_FORTRAN)
   case g77:
      set OPT = '-O2'
      if ($MODULE == zheev) set OPT='-O0'
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      if (($MODULE == iolib) || ($MODULE == inputa) || \
          ($MODULE == gamess) || ($MODULE == mp2ims)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/MXUNIT=299/MXUNIT=99/g" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      set echo
      g77 -c $OPT -fautomatic -Wno-globals -fno-globals $MODULE.f
      unset echo
      breaksw
   case gfortran:
      set OPT='-O2'
      if ($MODULE == zheev)  set OPT='-O0'  # defensive compiling
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      set echo
      gfortran -c $OPT -std=legacy $MODULE.f
      unset echo
      breaksw
   default:
      echo "unrecognized compiler passed to -mac32- target: $GMS_FORTRAN"
      exit 55
      breaksw
   endsw
endif
#
if ($TARGET == mac64) then
   set OPT='-O2'
   if ($MODULE == zheev)  set OPT='-O0'  # defensive compiling
   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   set echo
   gfortran -c -m64 -fdefault-integer-8 $OPT -std=legacy $MODULE.f
   unset echo
endif
#
# Options for f90 under SUPER-UX on the NEC SX Series are
#      -ebw enable passing scalar arguments and set all word size 64bit
#      -size_t64 flags 64bit size_t and associated libraries
#      -pvtcl noassume vwork=stack sets vectorization temporaries parameters
#      -Nv  vectorization is turned off
#
if ($TARGET == necsx) then
   set OPT = '-Wf"-v -pvctl noassume vwork=stack"'
   if ($MODULE == mcqdpt) \
       set OPT='-Wf"-v -pvctl noassume vwork=stack noaltcode nodivloop -NO"'
   if ($MODULE == ddi) \
       set OPT='-Wf"-v -pvctl noassume vwork=stack -I /usr/include"'
#         compiler character problem
   if ($MODULE == inputc) set OPT='-Wf"-Nv"'
#         next ones are faster in scalar
   if ($MODULE == int2a)  set OPT='-Wf"-Nv"'
   if ($MODULE == int2b)  set OPT='-Wf"-Nv"'
   if ($MODULE == grd2a)  set OPT='-Wf"-Nv"'
   if ($MODULE == grd2b)  set OPT='-Wf"-Nv"'
   if ($MODULE == grd2c)  set OPT='-Wf"-Nv"'
   if ($MODULE == gugem)  set OPT='-Wf"-Nv"'
   if ($MODULE == gugdrt) set OPT='-Wf"-Nv"'
#
   set echo
   f90 -c -ebw -size_t64 $OPT $MODULE.f
   unset echo
endif
#
#  Options for SGI f77 under Irix, this pertains only to MIPS processors.
#  If you have XE blades or Altix from SGI, please use target 'linux64'.
#
#  Different versions of the SGI compiler may not work with the fairly
#  aggressive -O3 optimization used below.  If you experience any numerical
#  problems, please try using -O2 rather than -O3 below.  It is unsafe to
#  use very aggressive optimizations like "-OPT:IEEE_arith=3:roundoff=3".
#
#  If you use f90, do not reset the units for RECL in the sed hacks above.
#
#  -i8/-i4 selects 8/4 byte integer and logical data types.
#  -show would add verbose printing of compiler phase information.
#  -automatic is the opposite of -static storage allocation.
#  -OPT:Olimit=0 removes subroutine size optimization limits.
#  -woff suppresses warnings (2290=type checking on calling args).
#
if (($TARGET == sgi32) || ($TARGET == sgi64)) then
   set FORT=$GMS_FORTRAN
   set OPT='-O3'
   if ($MODULE == grd2a)  set OPT='-O2'
   if ($MODULE == grd2c)  set OPT='-O2'
   if ($MODULE == mcpinp) set OPT='-O2'
   if ($MODULE == mcpint) set OPT='-O2'
   if ($MODULE == rxncrd) set OPT='-O2'
   if ($MODULE == zheev)  set OPT='-O0'
   if ($MODULE == gmsnbo) set OPT='-O2 -backslash'
   if ($TARGET == sgi64) set INTS=' -64 -i8'
   if ($TARGET == sgi32) set INTS='-n32 -i4'
   set FLAGS='-automatic -G0 -woff 2290 -OPT:Olimit=0'
   set echo
   $FORT -c $OPT $INTS $FLAGS $MODULE.f
   unset echo
endif
#
#                  Solaris on Sun machines
#  There is a united clause for UltraSPARC and Opteron chips!
#
#  f90 compiler flags have the meaning:
#     -c        compile only
#     -v        print verbose information on compiler phases and options
#     -stackvar forces non-static storage
#     -fast     is a smorgasbord of all the below, if you wish to
#               override one you must *follow* the -fast with it.
#         -xtarget=native  (optimize for chip being compiled upon)
#         -O5        (see below)
#         -libmil    (inline some math routines)
#         -fsimple=2 (0,1,2 control floating point simplifications)
#         -dalign    (double word alignment and instructions)
#         -xlibmopt  (link to optimized math library)
#         -depend    (DO loop data dependency analysis)
#         -fns       (fast underflow handling)
#         -ftrap=common   (floating point error handling)
#         -xvector=yes    (select vectorized math library)
#         -xprefetch=yes  (auto generation of instruction prefetching)
#     -O1 = minimal optimization (must turn off -depend to use this)
#            you may want to set this a particular chip if you run
#            more times on a different system than you compile on.
#     -O2 = basic local and global optimizations (must turn off -depend)
#     -O3 = loop unrolling and additional global optimizations
#     -O4 = automatic inlining
#     -O5 = aggressive optimizations
#  Experience suggests that setting OPT to '-fast -O2 -nodepend' is
#  normally very safe, for any Solaris/f90 versions.
#
#  Address space selection up to SunSuite 11 is by -xarch=nnn,
#  where the more likely values for nnn might be
#     v8plus        any UltraSPARC, using 32 bit instructions
#     v9            any UltraSPARC, using 64 bit instruction set
#     pentium_pro   most Intel chips, using 32 bits
#     amd64         Opteron, using 64 bits
#  "uname -p" says the processor is sparc or i386, as a generic reply,
#  allowing us to distinguish the families, e.g. Opteron replies "i386"!
#  N.B.  We have not tested the "pentium_pro" 32 bit stuff below.
#
#  Sun Studio 12 (f90 version 8.3, type "f90 -V" to see your version)
#  changed to more rational address space specifiers -m32 or -m64.
#
#  Following is a potted history of Solaris versions that support
#  UltraSPARC chips.  64 bit O/S support came with Solaris 7, and
#  support for the UltraSPARC III chip came with Forte/f90 6.1.
#      year  Solaris   compilers      FORTRAN
#      1997   2.6      WorkShop 3.0   f77 4.2
#      1998     7      WorkShop 5.0   f90 2.0
#      2000     8      Forte 6        f90 6.0
#      2002     9      Forte 7        f90 7.0
#      2005    10      Sun Studio 10  f90 8.1
#      2008     ?      Sun Studio 12  f90 8.3
#  Version of   Solaris: "uname -sr", reply of 5.6 means 2.6, 5.9 means 9.
#  Version runs  64 bit: "isainfo -v"
#  Version of   FORTRAN: "f77 -V" or "f90 -V"
#  Version of processor: "fpversion", look at the -xtarget response.
#
if (($TARGET == sun32) || ($TARGET == sun64)) then
   if ($GMS_SUN_OS_VERNO >= 7) then
      set xxx=$GMS_SUN_FORT_VERNO
      set f90_major=$xxx:r
      set f90_minor=$xxx:e
                                                  set newf90=false
      if (($f90_major == 8) && ($f90_minor >= 3)) set newf90=true
      if  ($f90_major >= 9)                       set newf90=true
#
#            For Solaris newer than 1998, config tries to force to sun64,
#            but someone could (if crazy) reset the gamess.config to sun32.
      if ($TARGET == sun32) then
         set BITS=32
         if ($newf90 == true) then
            set ARCH=-m32
         else
            if (`uname -p` == sparc) set ARCH='-xarch=v8plus'
            if (`uname -p` == i386)  set ARCH='-xarch=pentium_pro'
         endif
      endif
#
      if ($TARGET == sun64) then
         set BITS=64
         if ($newf90 == true) then
            set ARCH=-m64
         else
            if (`uname -p` == sparc) set ARCH='-xarch=v9'
            if (`uname -p` == i386)  set ARCH='-xarch=amd64'
         endif
      endif
#         the Opteron does not support quadruple precision.
#         However, SPARC chips do just fine with q.p.
      if (`uname -p` == i386) then
         if (($MODULE == qeigen) || ($MODULE == int2c)) then
            mv -f $MODULE.f $MODULE.junk
            sed -e "s/Q-/D-/g" \
                -e "s/Q+00/D+00/g" \
                -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
            rm -f $MODULE.junk
         endif
      endif
#
      set OPT='-fast -O4'
#       next are detunings for f90 7.5 under Solaris 9 on SPARC,
#                detunings for f90 8.1 under Solaris 10 on Opteron,
#       and a few more discoverd by people with other compiler versions.
      if ($MODULE == grd2b)  set OPT='-fast -O2 -nodepend'
      if ($MODULE == grd2c)  set OPT='-fast -O2 -nodepend'
      if ($MODULE == gugdrt) set OPT='-fast -O2 -nodepend'
      if ($MODULE == eigen)  set OPT='      -O2          '
      if ($MODULE == mcpgrd) set OPT='-fast -O4 -nodepend'
      if ($MODULE == mp2ddi) set OPT='-fast -O4 -nodepend'
      if ($MODULE == scfmi)  set OPT='-fast -O4 -nodepend'
      if ($MODULE == trnstn) set OPT='-fast -O2 -nodepend'
      if ($MODULE == umpddi) set OPT='-fast -O4 -nodepend'
      if ($MODULE == vibanl) set OPT='-fast -O4 -nodepend'  # for PRJGRD
      if ($MODULE == zheev)  set OPT='-O0'
      set WARN='-erroff=WARNING_1278,WARNING_1279,WARNING_1615'
      set echo
      f90 -c -stackvar -xtypemap=integer:$BITS $OPT $WARN $ARCH $MODULE.f
      unset echo
   else
#
#        Solaris up to 1997 was SPARC (here we default to UltraSPARC)
#        and was a 32 bit compile, and used f77!
#        If you have a pre-ultraSPARC system, try OPT='-O2' or '-O3' while
#        eliminating the -xarch flag, and you might also need -Nl30.
#        Solaris did run on Intel chips, try -xarch=pentium_pro for that?
#        The options below are our E450, still chugging after all these years.
      set OPT='-fast -O4 -xarch=v8plus'
      if ($MODULE == ddi)    set OPT='-fast -O4 -nodepend -xarch=v8plus'
      if ($MODULE == grd2c)  set OPT='-fast -O4 -nodepend -xarch=v8plus'
      if ($MODULE == ormas1) set OPT='-fast -O4 -nodepend -xarch=v8plus'
      if ($MODULE == symslc) set OPT='-fast -O4 -nodepend -xarch=v8plus'
      if ($MODULE == zheev)  set OPT='-O0'
      set echo
      f77 -c $OPT -stackvar $MODULE.f
      unset echo
   endif
endif
#
#   ------ Windows on 32 bit chips ------
#
if ($TARGET == win32) then
    switch ($GMS_FORTRAN)
#
#    1. Portland Group (PGI) Compiler
#
#    This is a synthesis of recommendations from Fred Arnold and Brian
#    Salter-Duke.  -fast means -O2 -Munroll -Mnoframe, the latter option
#    seems to be the source of several incorrect results.  It is said that
#    "-Munroll" and "-tp p6" gives no significant improvement in run times.
#
   case pgf77:
   if (($MODULE == qfmm) || ($MODULE == solib) || ($MODULE == zheev)) then
       mv -f $MODULE.f $MODULE.junk
       sed -e s/DREAL/DBLE/g $MODULE.junk > $MODULE.f
       rm -f $MODULE.junk
   endif
   if (($MODULE == qeigen) || ($MODULE == int2c)) then
      mv -f $MODULE.f $MODULE.junk
      sed -e "s/Q-/D-/g" \
          -e "s/Q+00/D+00/g" \
          -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
      rm -f $MODULE.junk
   endif
   if ($GMS_WIN_OPT == baseline) then
     set OPT = '-O0'
     if ($MODULE == zheev)  set OPT = "$OPT -Kieee"
   endif
   if ($GMS_WIN_OPT == linux) then
     set OPT = '-O2'
     if ($MODULE == zheev)  set OPT = '-Kieee'
     if ($MODULE == bassto) set OPT = '-O0'
   endif
   if ($GMS_WIN_OPT == fast) then
     set OPT = '-fast -Mipa=fast,safe'
     if ($MODULE == zheev)  set OPT = '-Kieee'
     if ($MODULE == bassto) set OPT = '-O0'
     if ($MODULE == fmo)    set OPT = '-fast'
   endif
   if ($GMS_WIN_OPT == testing) then
     set OPT = '-fast -Mipa=fast,safe'
     if ($MODULE == zheev)  set OPT = "-Kieee $GMS_WIN_FLAGS"
     if ($MODULE == bassto) set OPT = "-O0 $GMS_WIN_FLAGS"
     if ($MODULE == fmo)    set OPT = "-fast $GMS_WIN_FLAGS"
   endif
#
#  For more detailed information as to which flags are being used
#  by the compiler during the build - uncomment the line below.
#
#  set OPT = "$OPT -v"
#
   set echo
   pgf77 -c -Msecond_underscore -Munix -Bstatic $OPT $GMS_WIN_TP \
         -o $MODULE.o $MODULE.f
   unset echo
   breaksw
#
   default:
      echo "Please spell your Windows 32 bit FORTRAN compiler name correctly."
      exit 4
      breaksw
   endsw
#                     ... end of Windows on 32 bit processors.
endif
#
#   ------ Windows on 64 bit chips ------
#
if ($TARGET == win64) then
   switch ($GMS_FORTRAN)
   case pgf77:
      if (($MODULE == qeigen) || ($MODULE == int2c)) then
         mv -f $MODULE.f $MODULE.junk
         sed -e "s/Q-/D-/g" \
             -e "s/Q+00/D+00/g" \
             -e "s/REAL\*16/DOUBLE PRECISION/" $MODULE.junk > $MODULE.f
         rm -f $MODULE.junk
      endif
      if ($GMS_WIN_OPT == baseline) then
        set OPT = '-O0'
      endif
      if ($GMS_WIN_OPT == linux) then
        set OPT = '-fastsse -Mipa=fast,safe -Mprof=func'
        if ($MODULE == int2b)  set OPT = "$OPT -Mnounroll"
        if ($MODULE == mcpgrd) set OPT = '-O1'
        if ($MODULE =~ mpc*)   set OPT = '-Mprof=func -O0'
        if ($MODULE == zheev)  set OPT = '-Mprof=func -O0'
      endif
      if ($GMS_WIN_OPT == fast) then
        set OPT = '-fast -Mipa=fast,safe'
        if ($MODULE == int2b)  set OPT = "$OPT -Mnounroll"
        if ($MODULE == mcpgrd) set OPT = '-O1'
        if ($MODULE =~ mpc*)   set OPT = '-O0'
        if ($MODULE == zheev)  set OPT = '-O0'        # defensive compiling
      endif
      if ($GMS_WIN_OPT == testing) then
        set OPT = "-fast -Mipa=fast,safe $GMS_WIN_FLAGS"
        if ($MODULE == int2b)  set OPT = "$OPT -Mnounroll"
        if ($MODULE == mcpgrd) set OPT = "-O1 $GMS_WIN_FLAGS"
        if ($MODULE =~ mpc*)   set OPT = "-O0 $GMS_WIN_FLAGS"
        if ($MODULE == zheev)  set OPT = "-O0 $GMS_WIN_FLAGS"
      endif
#
#     For more detailed information as to which flags are being used
#     by the compiler during the build - uncomment the line below.
#
#     set OPT = "$OPT -v"
#
      set echo
      pgf77 -c -i8 -Bstatic $OPT $GMS_WIN_TP -o $MODULE.o $MODULE.f
      unset echo
      breaksw
#
   default:
      echo "Please spell your Windows 64 bit FORTRAN compiler name correctly."
      exit 4
      breaksw
   endsw
#                     ... end of Windows on 64 bit processors.
endif
#
#  Store the generated object code, clean up, and quit
#
mv -f $MODULE.o $OBJDIR/$MODULE.o
if ($TINKCODE == yes) exit
#
#  option to possibly save the preprocessed code, out of the way
#
if ( ".$GMS_DEBUG_FLAGS" == '.' ) then
   rm -f $MODULE.f
else
   mv -f $MODULE.f tmp/
endif
if ($SRCDIR == .) rm -f $MODULE.src    # delete copy with no scalar code
#
#  Exit gracelessly if we fail to generate the object file
#
unset echo
date
time
if (-e object/$MODULE.o ) then
   exit
else
   echo Compilation failure for $MODULE, please fix the problem.
   exit 1
endif
